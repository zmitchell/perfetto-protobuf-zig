// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const structured_query = @import("src/gen/protos/perfetto/perfetto_sql/structured_query.proto.zig");
// structs
const TraceMetricV2SpecWire = struct {
    const ID_WIRE: gremlin.ProtoWireNumber = 1;
    const DIMENSIONS_SPECS_WIRE: gremlin.ProtoWireNumber = 5;
    const DIMENSIONS_WIRE: gremlin.ProtoWireNumber = 2;
    const VALUE_WIRE: gremlin.ProtoWireNumber = 3;
    const QUERY_WIRE: gremlin.ProtoWireNumber = 4;
    const DIMENSION_UNIQUENESS_WIRE: gremlin.ProtoWireNumber = 6;
    const POLARITY_WIRE: gremlin.ProtoWireNumber = 10;
    const BUNDLE_ID_WIRE: gremlin.ProtoWireNumber = 7;
    const INTERNED_DIMENSION_SPECS_WIRE: gremlin.ProtoWireNumber = 11;
    const UNIT_WIRE: gremlin.ProtoWireNumber = 8;
    const CUSTOM_UNIT_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const TraceMetricV2Spec = struct {
    // nested enums
    pub const DimensionType = enum(i32) {
        DIMENSION_TYPE_UNSPECIFIED = 0,
        STRING = 1,
        INT64 = 2,
        DOUBLE = 3,
        BOOLEAN = 4,
    };
    pub const DimensionUniqueness = enum(i32) {
        DIMENSION_UNIQUENESS_UNSPECIFIED = 0,
        NOT_UNIQUE = 1,
        UNIQUE = 2,
    };
    pub const MetricUnit = enum(i32) {
        METRIC_UNIT_UNSPECIFIED = 0,
        COUNT = 1,
        TIME_NANOS = 2,
        TIME_MICROS = 3,
        TIME_MILLIS = 4,
        TIME_SECONDS = 5,
        TIME_HOURS = 6,
        TIME_DAYS = 7,
        BYTES = 8,
        KILOBYTES = 9,
        MEGABYTES = 10,
        SECONDS_PER_HOUR = 11,
        BOUNDED_PERCENTAGE = 12,
        PERCENTAGE = 13,
        MINUTES_PER_DAY = 14,
        MILLI_AMPS = 15,
        PERCENT_PER_HOUR = 16,
        MILLI_AMP_HOURS = 17,
        PERCENT_PER_HOUR_LEGACY = 18,
        MILLI_WATTS = 19,
        COUNT_PER_SECOND = 20,
        KILOBYTES_PER_HOUR = 21,
        MILLI_WATT_HOURS = 22,
        COUNT_PER_HOUR = 23,
        COUNT_DELTA_PER_HOUR = 24,
        BYTES_DELTA_PER_HOUR = 25,
        CORRELATION_COEFFICIENT = 26,
        MILLI_VOLTS = 27,
    };
    pub const MetricPolarity = enum(i32) {
        POLARITY_UNSPECIFIED = 0,
        HIGHER_IS_BETTER = 1,
        LOWER_IS_BETTER = 2,
        NOT_APPLICABLE = 3,
    };
    // nested structs
    const DimensionSpecWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const DimensionSpec = struct {
        // fields
        name: ?[]const u8 = null,
        type: TraceMetricV2Spec.DimensionType = @enumFromInt(0),
        pub fn calcProtobufSize(self: *const TraceMetricV2Spec.DimensionSpec) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.DimensionSpecWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.type) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.DimensionSpecWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
            }
            return res;
        }
        pub fn encode(self: *const TraceMetricV2Spec.DimensionSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceMetricV2Spec.DimensionSpec, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceMetricV2Spec.DimensionSpecWire.NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.type) != 0) {
                target.appendInt32(TraceMetricV2Spec.DimensionSpecWire.TYPE_WIRE, @intFromEnum(self.type));
            }
        }
    };
    pub const DimensionSpecReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _type: TraceMetricV2Spec.DimensionType = @enumFromInt(0),
        pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Spec.DimensionSpecReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceMetricV2Spec.DimensionSpecReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceMetricV2Spec.DimensionSpecWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    TraceMetricV2Spec.DimensionSpecWire.TYPE_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._type = @enumFromInt(result.value);
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const TraceMetricV2Spec.DimensionSpecReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getType(self: *const TraceMetricV2Spec.DimensionSpecReader) TraceMetricV2Spec.DimensionType {
            return self._type;
        }
    };
    const InternedDimensionSpecWire = struct {
        const KEY_COLUMN_SPEC_WIRE: gremlin.ProtoWireNumber = 1;
        const DATA_COLUMN_SPECS_WIRE: gremlin.ProtoWireNumber = 2;
        const QUERY_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const InternedDimensionSpec = struct {
        // nested structs
        const ColumnSpecWire = struct {
            const NAME_WIRE: gremlin.ProtoWireNumber = 1;
            const TYPE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const ColumnSpec = struct {
            // fields
            name: ?[]const u8 = null,
            type: TraceMetricV2Spec.DimensionType = @enumFromInt(0),
            pub fn calcProtobufSize(self: *const TraceMetricV2Spec.InternedDimensionSpec.ColumnSpec) usize {
                var res: usize = 0;
                if (self.name) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (@intFromEnum(self.type) != 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.type));
                }
                return res;
            }
            pub fn encode(self: *const TraceMetricV2Spec.InternedDimensionSpec.ColumnSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceMetricV2Spec.InternedDimensionSpec.ColumnSpec, target: *gremlin.Writer) void {
                if (self.name) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.NAME_WIRE, v);
                    }
                }
                if (@intFromEnum(self.type) != 0) {
                    target.appendInt32(TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.TYPE_WIRE, @intFromEnum(self.type));
                }
            }
        };
        pub const ColumnSpecReader = struct {
            buf: gremlin.Reader,
            _name: ?[]const u8 = null,
            _type: TraceMetricV2Spec.DimensionType = @enumFromInt(0),
            pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.NAME_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._name = result.value;
                        },
                        TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecWire.TYPE_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._type = @enumFromInt(result.value);
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getName(self: *const TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader) []const u8 {
                return self._name orelse &[_]u8{};
            }
            pub inline fn getType(self: *const TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader) TraceMetricV2Spec.DimensionType {
                return self._type;
            }
        };
        // fields
        key_column_spec: ?TraceMetricV2Spec.InternedDimensionSpec.ColumnSpec = null,
        data_column_specs: ?[]const ?TraceMetricV2Spec.InternedDimensionSpec.ColumnSpec = null,
        query: ?structured_query.PerfettoSqlStructuredQuery = null,
        pub fn calcProtobufSize(self: *const TraceMetricV2Spec.InternedDimensionSpec) usize {
            var res: usize = 0;
            if (self.key_column_spec) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.InternedDimensionSpecWire.KEY_COLUMN_SPEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.data_column_specs) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.InternedDimensionSpecWire.DATA_COLUMN_SPECS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Spec.InternedDimensionSpecWire.QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceMetricV2Spec.InternedDimensionSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceMetricV2Spec.InternedDimensionSpec, target: *gremlin.Writer) void {
            if (self.key_column_spec) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(TraceMetricV2Spec.InternedDimensionSpecWire.KEY_COLUMN_SPEC_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.data_column_specs) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TraceMetricV2Spec.InternedDimensionSpecWire.DATA_COLUMN_SPECS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TraceMetricV2Spec.InternedDimensionSpecWire.DATA_COLUMN_SPECS_WIRE, 0);
                    }
                }
            }
            if (self.query) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(TraceMetricV2Spec.InternedDimensionSpecWire.QUERY_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const InternedDimensionSpecReader = struct {
        buf: gremlin.Reader,
        _key_column_spec_buf: ?[]const u8 = null,
        _data_column_specs_offset: ?usize = null,
        _data_column_specs_last_offset: ?usize = null,
        _data_column_specs_cnt: usize = 0,
        _query_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Spec.InternedDimensionSpecReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceMetricV2Spec.InternedDimensionSpecReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceMetricV2Spec.InternedDimensionSpecWire.KEY_COLUMN_SPEC_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._key_column_spec_buf = result.value;
                    },
                    TraceMetricV2Spec.InternedDimensionSpecWire.DATA_COLUMN_SPECS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._data_column_specs_offset == null) {
                            res._data_column_specs_offset = offset - result.size;
                        }
                        res._data_column_specs_last_offset = offset;
                        res._data_column_specs_cnt += 1;
                    },
                    TraceMetricV2Spec.InternedDimensionSpecWire.QUERY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._query_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getKeyColumnSpec(self: *const TraceMetricV2Spec.InternedDimensionSpecReader) gremlin.Error!TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader {
            if (self._key_column_spec_buf) |buf| {
                return try TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader.init(buf);
            }
            return try TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader.init(&[_]u8{});
        }
        pub fn dataColumnSpecsCount(self: *const TraceMetricV2Spec.InternedDimensionSpecReader) usize {
            return self._data_column_specs_cnt;
        }
        pub fn dataColumnSpecsNext(self: *TraceMetricV2Spec.InternedDimensionSpecReader) ?TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader {
            if (self._data_column_specs_offset == null) return null;
            const current_offset = self._data_column_specs_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TraceMetricV2Spec.InternedDimensionSpec.ColumnSpecReader.init(result.value) catch return null;
            if (self._data_column_specs_last_offset != null and current_offset >= self._data_column_specs_last_offset.?) {
                self._data_column_specs_offset = null;
                return msg;
            }
            if (self._data_column_specs_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._data_column_specs_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceMetricV2Spec.InternedDimensionSpecWire.DATA_COLUMN_SPECS_WIRE) {
                    self._data_column_specs_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._data_column_specs_offset = null;
            return msg;
        }
        pub fn getQuery(self: *const TraceMetricV2Spec.InternedDimensionSpecReader) gremlin.Error!structured_query.PerfettoSqlStructuredQueryReader {
            if (self._query_buf) |buf| {
                return try structured_query.PerfettoSqlStructuredQueryReader.init(buf);
            }
            return try structured_query.PerfettoSqlStructuredQueryReader.init(&[_]u8{});
        }
    };
    // fields
    id: ?[]const u8 = null,
    dimensions_specs: ?[]const ?TraceMetricV2Spec.DimensionSpec = null,
    dimensions: ?[]const ?[]const u8 = null,
    value: ?[]const u8 = null,
    query: ?structured_query.PerfettoSqlStructuredQuery = null,
    dimension_uniqueness: TraceMetricV2Spec.DimensionUniqueness = @enumFromInt(0),
    polarity: TraceMetricV2Spec.MetricPolarity = @enumFromInt(0),
    bundle_id: ?[]const u8 = null,
    interned_dimension_specs: ?[]const ?TraceMetricV2Spec.InternedDimensionSpec = null,
    unit: TraceMetricV2Spec.MetricUnit = @enumFromInt(0),
    custom_unit: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TraceMetricV2Spec) usize {
        var res: usize = 0;
        if (self.id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.dimensions_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.DIMENSIONS_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.dimensions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.DIMENSIONS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.value) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.dimension_uniqueness) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.DIMENSION_UNIQUENESS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.dimension_uniqueness));
        }
        if (@intFromEnum(self.polarity) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.POLARITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.polarity));
        }
        if (self.bundle_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.BUNDLE_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.interned_dimension_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.INTERNED_DIMENSION_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.unit) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.UNIT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.unit));
        }
        if (self.custom_unit) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2SpecWire.CUSTOM_UNIT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceMetricV2Spec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceMetricV2Spec, target: *gremlin.Writer) void {
        if (self.id) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2SpecWire.ID_WIRE, v);
            }
        }
        if (self.dimensions_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2SpecWire.DIMENSIONS_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2SpecWire.DIMENSIONS_SPECS_WIRE, 0);
                }
            }
        }
        if (self.dimensions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceMetricV2SpecWire.DIMENSIONS_WIRE, v);
                } else {
                    target.appendBytesTag(TraceMetricV2SpecWire.DIMENSIONS_WIRE, 0);
                }
            }
        }
        if (self.value) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2SpecWire.VALUE_WIRE, v);
            }
        }
        if (self.query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricV2SpecWire.QUERY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.dimension_uniqueness) != 0) {
            target.appendInt32(TraceMetricV2SpecWire.DIMENSION_UNIQUENESS_WIRE, @intFromEnum(self.dimension_uniqueness));
        }
        if (@intFromEnum(self.polarity) != 0) {
            target.appendInt32(TraceMetricV2SpecWire.POLARITY_WIRE, @intFromEnum(self.polarity));
        }
        if (self.bundle_id) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2SpecWire.BUNDLE_ID_WIRE, v);
            }
        }
        if (self.interned_dimension_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2SpecWire.INTERNED_DIMENSION_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2SpecWire.INTERNED_DIMENSION_SPECS_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.unit) != 0) {
            target.appendInt32(TraceMetricV2SpecWire.UNIT_WIRE, @intFromEnum(self.unit));
        }
        if (self.custom_unit) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2SpecWire.CUSTOM_UNIT_WIRE, v);
            }
        }
    }
};
pub const TraceMetricV2SpecReader = struct {
    buf: gremlin.Reader,
    _id: ?[]const u8 = null,
    _dimensions_specs_offset: ?usize = null,
    _dimensions_specs_last_offset: ?usize = null,
    _dimensions_specs_cnt: usize = 0,
    _dimensions_offset: ?usize = null,
    _dimensions_last_offset: ?usize = null,
    _dimensions_cnt: usize = 0,
    _value: ?[]const u8 = null,
    _query_buf: ?[]const u8 = null,
    _dimension_uniqueness: TraceMetricV2Spec.DimensionUniqueness = @enumFromInt(0),
    _polarity: TraceMetricV2Spec.MetricPolarity = @enumFromInt(0),
    _bundle_id: ?[]const u8 = null,
    _interned_dimension_specs_offset: ?usize = null,
    _interned_dimension_specs_last_offset: ?usize = null,
    _interned_dimension_specs_cnt: usize = 0,
    _unit: TraceMetricV2Spec.MetricUnit = @enumFromInt(0),
    _custom_unit: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TraceMetricV2SpecReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceMetricV2SpecReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceMetricV2SpecWire.ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._id = result.value;
                },
                TraceMetricV2SpecWire.DIMENSIONS_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dimensions_specs_offset == null) {
                        res._dimensions_specs_offset = offset - result.size;
                    }
                    res._dimensions_specs_last_offset = offset;
                    res._dimensions_specs_cnt += 1;
                },
                TraceMetricV2SpecWire.DIMENSIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dimensions_offset == null) {
                        res._dimensions_offset = offset - result.size;
                    }
                    res._dimensions_last_offset = offset;
                    res._dimensions_cnt += 1;
                },
                TraceMetricV2SpecWire.VALUE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._value = result.value;
                },
                TraceMetricV2SpecWire.QUERY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._query_buf = result.value;
                },
                TraceMetricV2SpecWire.DIMENSION_UNIQUENESS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dimension_uniqueness = @enumFromInt(result.value);
                },
                TraceMetricV2SpecWire.POLARITY_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._polarity = @enumFromInt(result.value);
                },
                TraceMetricV2SpecWire.BUNDLE_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bundle_id = result.value;
                },
                TraceMetricV2SpecWire.INTERNED_DIMENSION_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._interned_dimension_specs_offset == null) {
                        res._interned_dimension_specs_offset = offset - result.size;
                    }
                    res._interned_dimension_specs_last_offset = offset;
                    res._interned_dimension_specs_cnt += 1;
                },
                TraceMetricV2SpecWire.UNIT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._unit = @enumFromInt(result.value);
                },
                TraceMetricV2SpecWire.CUSTOM_UNIT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._custom_unit = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getId(self: *const TraceMetricV2SpecReader) []const u8 {
        return self._id orelse &[_]u8{};
    }
    pub fn dimensionsSpecsCount(self: *const TraceMetricV2SpecReader) usize {
        return self._dimensions_specs_cnt;
    }
    pub fn dimensionsSpecsNext(self: *TraceMetricV2SpecReader) ?TraceMetricV2Spec.DimensionSpecReader {
        if (self._dimensions_specs_offset == null) return null;
        const current_offset = self._dimensions_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Spec.DimensionSpecReader.init(result.value) catch return null;
        if (self._dimensions_specs_last_offset != null and current_offset >= self._dimensions_specs_last_offset.?) {
            self._dimensions_specs_offset = null;
            return msg;
        }
        if (self._dimensions_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dimensions_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2SpecWire.DIMENSIONS_SPECS_WIRE) {
                self._dimensions_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dimensions_specs_offset = null;
        return msg;
    }
    pub fn dimensionsCount(self: *const TraceMetricV2SpecReader) usize {
        return self._dimensions_cnt;
    }
    pub fn dimensionsNext(self: *TraceMetricV2SpecReader) ?[]const u8 {
        if (self._dimensions_offset == null) return null;
        const current_offset = self._dimensions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._dimensions_last_offset != null and current_offset >= self._dimensions_last_offset.?) {
            self._dimensions_offset = null;
            return result.value;
        }
        if (self._dimensions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dimensions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2SpecWire.DIMENSIONS_WIRE) {
                self._dimensions_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dimensions_offset = null;
        return result.value;
    }
    pub inline fn getValue(self: *const TraceMetricV2SpecReader) []const u8 {
        return self._value orelse &[_]u8{};
    }
    pub fn getQuery(self: *const TraceMetricV2SpecReader) gremlin.Error!structured_query.PerfettoSqlStructuredQueryReader {
        if (self._query_buf) |buf| {
            return try structured_query.PerfettoSqlStructuredQueryReader.init(buf);
        }
        return try structured_query.PerfettoSqlStructuredQueryReader.init(&[_]u8{});
    }
    pub inline fn getDimensionUniqueness(self: *const TraceMetricV2SpecReader) TraceMetricV2Spec.DimensionUniqueness {
        return self._dimension_uniqueness;
    }
    pub inline fn getPolarity(self: *const TraceMetricV2SpecReader) TraceMetricV2Spec.MetricPolarity {
        return self._polarity;
    }
    pub inline fn getBundleId(self: *const TraceMetricV2SpecReader) []const u8 {
        return self._bundle_id orelse &[_]u8{};
    }
    pub fn internedDimensionSpecsCount(self: *const TraceMetricV2SpecReader) usize {
        return self._interned_dimension_specs_cnt;
    }
    pub fn internedDimensionSpecsNext(self: *TraceMetricV2SpecReader) ?TraceMetricV2Spec.InternedDimensionSpecReader {
        if (self._interned_dimension_specs_offset == null) return null;
        const current_offset = self._interned_dimension_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Spec.InternedDimensionSpecReader.init(result.value) catch return null;
        if (self._interned_dimension_specs_last_offset != null and current_offset >= self._interned_dimension_specs_last_offset.?) {
            self._interned_dimension_specs_offset = null;
            return msg;
        }
        if (self._interned_dimension_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._interned_dimension_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2SpecWire.INTERNED_DIMENSION_SPECS_WIRE) {
                self._interned_dimension_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._interned_dimension_specs_offset = null;
        return msg;
    }
    pub inline fn getUnit(self: *const TraceMetricV2SpecReader) TraceMetricV2Spec.MetricUnit {
        return self._unit;
    }
    pub inline fn getCustomUnit(self: *const TraceMetricV2SpecReader) []const u8 {
        return self._custom_unit orelse &[_]u8{};
    }
};
const TraceMetricV2TemplateSpecWire = struct {
    const ID_PREFIX_WIRE: gremlin.ProtoWireNumber = 1;
    const DIMENSIONS_SPECS_WIRE: gremlin.ProtoWireNumber = 5;
    const DIMENSIONS_WIRE: gremlin.ProtoWireNumber = 2;
    const VALUE_COLUMNS_WIRE: gremlin.ProtoWireNumber = 3;
    const VALUE_COLUMN_SPECS_WIRE: gremlin.ProtoWireNumber = 8;
    const INTERNED_DIMENSION_SPECS_WIRE: gremlin.ProtoWireNumber = 9;
    const QUERY_WIRE: gremlin.ProtoWireNumber = 4;
    const DIMENSION_UNIQUENESS_WIRE: gremlin.ProtoWireNumber = 6;
    const DISABLE_AUTO_BUNDLING_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const TraceMetricV2TemplateSpec = struct {
    // nested structs
    const ValueColumnSpecWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const POLARITY_WIRE: gremlin.ProtoWireNumber = 4;
        const UNIT_WIRE: gremlin.ProtoWireNumber = 2;
        const CUSTOM_UNIT_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const ValueColumnSpec = struct {
        // fields
        name: ?[]const u8 = null,
        polarity: TraceMetricV2Spec.MetricPolarity = @enumFromInt(0),
        unit: TraceMetricV2Spec.MetricUnit = @enumFromInt(0),
        custom_unit: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TraceMetricV2TemplateSpec.ValueColumnSpec) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpec.ValueColumnSpecWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (@intFromEnum(self.polarity) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpec.ValueColumnSpecWire.POLARITY_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.polarity));
            }
            if (@intFromEnum(self.unit) != 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpec.ValueColumnSpecWire.UNIT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.unit));
            }
            if (self.custom_unit) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpec.ValueColumnSpecWire.CUSTOM_UNIT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceMetricV2TemplateSpec.ValueColumnSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceMetricV2TemplateSpec.ValueColumnSpec, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceMetricV2TemplateSpec.ValueColumnSpecWire.NAME_WIRE, v);
                }
            }
            if (@intFromEnum(self.polarity) != 0) {
                target.appendInt32(TraceMetricV2TemplateSpec.ValueColumnSpecWire.POLARITY_WIRE, @intFromEnum(self.polarity));
            }
            if (@intFromEnum(self.unit) != 0) {
                target.appendInt32(TraceMetricV2TemplateSpec.ValueColumnSpecWire.UNIT_WIRE, @intFromEnum(self.unit));
            }
            if (self.custom_unit) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceMetricV2TemplateSpec.ValueColumnSpecWire.CUSTOM_UNIT_WIRE, v);
                }
            }
        }
    };
    pub const ValueColumnSpecReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _polarity: TraceMetricV2Spec.MetricPolarity = @enumFromInt(0),
        _unit: TraceMetricV2Spec.MetricUnit = @enumFromInt(0),
        _custom_unit: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TraceMetricV2TemplateSpec.ValueColumnSpecReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceMetricV2TemplateSpec.ValueColumnSpecReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceMetricV2TemplateSpec.ValueColumnSpecWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    TraceMetricV2TemplateSpec.ValueColumnSpecWire.POLARITY_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._polarity = @enumFromInt(result.value);
                    },
                    TraceMetricV2TemplateSpec.ValueColumnSpecWire.UNIT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._unit = @enumFromInt(result.value);
                    },
                    TraceMetricV2TemplateSpec.ValueColumnSpecWire.CUSTOM_UNIT_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._custom_unit = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const TraceMetricV2TemplateSpec.ValueColumnSpecReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getPolarity(self: *const TraceMetricV2TemplateSpec.ValueColumnSpecReader) TraceMetricV2Spec.MetricPolarity {
            return self._polarity;
        }
        pub inline fn getUnit(self: *const TraceMetricV2TemplateSpec.ValueColumnSpecReader) TraceMetricV2Spec.MetricUnit {
            return self._unit;
        }
        pub inline fn getCustomUnit(self: *const TraceMetricV2TemplateSpec.ValueColumnSpecReader) []const u8 {
            return self._custom_unit orelse &[_]u8{};
        }
    };
    // fields
    id_prefix: ?[]const u8 = null,
    dimensions_specs: ?[]const ?TraceMetricV2Spec.DimensionSpec = null,
    dimensions: ?[]const ?[]const u8 = null,
    value_columns: ?[]const ?[]const u8 = null,
    value_column_specs: ?[]const ?TraceMetricV2TemplateSpec.ValueColumnSpec = null,
    interned_dimension_specs: ?[]const ?TraceMetricV2Spec.InternedDimensionSpec = null,
    query: ?structured_query.PerfettoSqlStructuredQuery = null,
    dimension_uniqueness: TraceMetricV2Spec.DimensionUniqueness = @enumFromInt(0),
    disable_auto_bundling: bool = false,
    pub fn calcProtobufSize(self: *const TraceMetricV2TemplateSpec) usize {
        var res: usize = 0;
        if (self.id_prefix) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.ID_PREFIX_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.dimensions_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.DIMENSIONS_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.dimensions) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.DIMENSIONS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.value_columns) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.VALUE_COLUMNS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.value_column_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.VALUE_COLUMN_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.interned_dimension_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.INTERNED_DIMENSION_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.QUERY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.dimension_uniqueness) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.DIMENSION_UNIQUENESS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.dimension_uniqueness));
        }
        if (self.disable_auto_bundling != false) {
            res += gremlin.sizes.sizeWireNumber(TraceMetricV2TemplateSpecWire.DISABLE_AUTO_BUNDLING_WIRE) + gremlin.sizes.sizeBool(self.disable_auto_bundling);
        }
        return res;
    }
    pub fn encode(self: *const TraceMetricV2TemplateSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceMetricV2TemplateSpec, target: *gremlin.Writer) void {
        if (self.id_prefix) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2TemplateSpecWire.ID_PREFIX_WIRE, v);
            }
        }
        if (self.dimensions_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.DIMENSIONS_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.DIMENSIONS_SPECS_WIRE, 0);
                }
            }
        }
        if (self.dimensions) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceMetricV2TemplateSpecWire.DIMENSIONS_WIRE, v);
                } else {
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.DIMENSIONS_WIRE, 0);
                }
            }
        }
        if (self.value_columns) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceMetricV2TemplateSpecWire.VALUE_COLUMNS_WIRE, v);
                } else {
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.VALUE_COLUMNS_WIRE, 0);
                }
            }
        }
        if (self.value_column_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.VALUE_COLUMN_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.VALUE_COLUMN_SPECS_WIRE, 0);
                }
            }
        }
        if (self.interned_dimension_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.INTERNED_DIMENSION_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2TemplateSpecWire.INTERNED_DIMENSION_SPECS_WIRE, 0);
                }
            }
        }
        if (self.query) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceMetricV2TemplateSpecWire.QUERY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.dimension_uniqueness) != 0) {
            target.appendInt32(TraceMetricV2TemplateSpecWire.DIMENSION_UNIQUENESS_WIRE, @intFromEnum(self.dimension_uniqueness));
        }
        if (self.disable_auto_bundling != false) {
            target.appendBool(TraceMetricV2TemplateSpecWire.DISABLE_AUTO_BUNDLING_WIRE, self.disable_auto_bundling);
        }
    }
};
pub const TraceMetricV2TemplateSpecReader = struct {
    buf: gremlin.Reader,
    _id_prefix: ?[]const u8 = null,
    _dimensions_specs_offset: ?usize = null,
    _dimensions_specs_last_offset: ?usize = null,
    _dimensions_specs_cnt: usize = 0,
    _dimensions_offset: ?usize = null,
    _dimensions_last_offset: ?usize = null,
    _dimensions_cnt: usize = 0,
    _value_columns_offset: ?usize = null,
    _value_columns_last_offset: ?usize = null,
    _value_columns_cnt: usize = 0,
    _value_column_specs_offset: ?usize = null,
    _value_column_specs_last_offset: ?usize = null,
    _value_column_specs_cnt: usize = 0,
    _interned_dimension_specs_offset: ?usize = null,
    _interned_dimension_specs_last_offset: ?usize = null,
    _interned_dimension_specs_cnt: usize = 0,
    _query_buf: ?[]const u8 = null,
    _dimension_uniqueness: TraceMetricV2Spec.DimensionUniqueness = @enumFromInt(0),
    _disable_auto_bundling: bool = false,
    pub fn init(src: []const u8) gremlin.Error!TraceMetricV2TemplateSpecReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceMetricV2TemplateSpecReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceMetricV2TemplateSpecWire.ID_PREFIX_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._id_prefix = result.value;
                },
                TraceMetricV2TemplateSpecWire.DIMENSIONS_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dimensions_specs_offset == null) {
                        res._dimensions_specs_offset = offset - result.size;
                    }
                    res._dimensions_specs_last_offset = offset;
                    res._dimensions_specs_cnt += 1;
                },
                TraceMetricV2TemplateSpecWire.DIMENSIONS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._dimensions_offset == null) {
                        res._dimensions_offset = offset - result.size;
                    }
                    res._dimensions_last_offset = offset;
                    res._dimensions_cnt += 1;
                },
                TraceMetricV2TemplateSpecWire.VALUE_COLUMNS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._value_columns_offset == null) {
                        res._value_columns_offset = offset - result.size;
                    }
                    res._value_columns_last_offset = offset;
                    res._value_columns_cnt += 1;
                },
                TraceMetricV2TemplateSpecWire.VALUE_COLUMN_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._value_column_specs_offset == null) {
                        res._value_column_specs_offset = offset - result.size;
                    }
                    res._value_column_specs_last_offset = offset;
                    res._value_column_specs_cnt += 1;
                },
                TraceMetricV2TemplateSpecWire.INTERNED_DIMENSION_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._interned_dimension_specs_offset == null) {
                        res._interned_dimension_specs_offset = offset - result.size;
                    }
                    res._interned_dimension_specs_last_offset = offset;
                    res._interned_dimension_specs_cnt += 1;
                },
                TraceMetricV2TemplateSpecWire.QUERY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._query_buf = result.value;
                },
                TraceMetricV2TemplateSpecWire.DIMENSION_UNIQUENESS_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._dimension_uniqueness = @enumFromInt(result.value);
                },
                TraceMetricV2TemplateSpecWire.DISABLE_AUTO_BUNDLING_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._disable_auto_bundling = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getIdPrefix(self: *const TraceMetricV2TemplateSpecReader) []const u8 {
        return self._id_prefix orelse &[_]u8{};
    }
    pub fn dimensionsSpecsCount(self: *const TraceMetricV2TemplateSpecReader) usize {
        return self._dimensions_specs_cnt;
    }
    pub fn dimensionsSpecsNext(self: *TraceMetricV2TemplateSpecReader) ?TraceMetricV2Spec.DimensionSpecReader {
        if (self._dimensions_specs_offset == null) return null;
        const current_offset = self._dimensions_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Spec.DimensionSpecReader.init(result.value) catch return null;
        if (self._dimensions_specs_last_offset != null and current_offset >= self._dimensions_specs_last_offset.?) {
            self._dimensions_specs_offset = null;
            return msg;
        }
        if (self._dimensions_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dimensions_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2TemplateSpecWire.DIMENSIONS_SPECS_WIRE) {
                self._dimensions_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dimensions_specs_offset = null;
        return msg;
    }
    pub fn dimensionsCount(self: *const TraceMetricV2TemplateSpecReader) usize {
        return self._dimensions_cnt;
    }
    pub fn dimensionsNext(self: *TraceMetricV2TemplateSpecReader) ?[]const u8 {
        if (self._dimensions_offset == null) return null;
        const current_offset = self._dimensions_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._dimensions_last_offset != null and current_offset >= self._dimensions_last_offset.?) {
            self._dimensions_offset = null;
            return result.value;
        }
        if (self._dimensions_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._dimensions_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2TemplateSpecWire.DIMENSIONS_WIRE) {
                self._dimensions_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._dimensions_offset = null;
        return result.value;
    }
    pub fn valueColumnsCount(self: *const TraceMetricV2TemplateSpecReader) usize {
        return self._value_columns_cnt;
    }
    pub fn valueColumnsNext(self: *TraceMetricV2TemplateSpecReader) ?[]const u8 {
        if (self._value_columns_offset == null) return null;
        const current_offset = self._value_columns_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._value_columns_last_offset != null and current_offset >= self._value_columns_last_offset.?) {
            self._value_columns_offset = null;
            return result.value;
        }
        if (self._value_columns_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._value_columns_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2TemplateSpecWire.VALUE_COLUMNS_WIRE) {
                self._value_columns_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._value_columns_offset = null;
        return result.value;
    }
    pub fn valueColumnSpecsCount(self: *const TraceMetricV2TemplateSpecReader) usize {
        return self._value_column_specs_cnt;
    }
    pub fn valueColumnSpecsNext(self: *TraceMetricV2TemplateSpecReader) ?TraceMetricV2TemplateSpec.ValueColumnSpecReader {
        if (self._value_column_specs_offset == null) return null;
        const current_offset = self._value_column_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2TemplateSpec.ValueColumnSpecReader.init(result.value) catch return null;
        if (self._value_column_specs_last_offset != null and current_offset >= self._value_column_specs_last_offset.?) {
            self._value_column_specs_offset = null;
            return msg;
        }
        if (self._value_column_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._value_column_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2TemplateSpecWire.VALUE_COLUMN_SPECS_WIRE) {
                self._value_column_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._value_column_specs_offset = null;
        return msg;
    }
    pub fn internedDimensionSpecsCount(self: *const TraceMetricV2TemplateSpecReader) usize {
        return self._interned_dimension_specs_cnt;
    }
    pub fn internedDimensionSpecsNext(self: *TraceMetricV2TemplateSpecReader) ?TraceMetricV2Spec.InternedDimensionSpecReader {
        if (self._interned_dimension_specs_offset == null) return null;
        const current_offset = self._interned_dimension_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Spec.InternedDimensionSpecReader.init(result.value) catch return null;
        if (self._interned_dimension_specs_last_offset != null and current_offset >= self._interned_dimension_specs_last_offset.?) {
            self._interned_dimension_specs_offset = null;
            return msg;
        }
        if (self._interned_dimension_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._interned_dimension_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2TemplateSpecWire.INTERNED_DIMENSION_SPECS_WIRE) {
                self._interned_dimension_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._interned_dimension_specs_offset = null;
        return msg;
    }
    pub fn getQuery(self: *const TraceMetricV2TemplateSpecReader) gremlin.Error!structured_query.PerfettoSqlStructuredQueryReader {
        if (self._query_buf) |buf| {
            return try structured_query.PerfettoSqlStructuredQueryReader.init(buf);
        }
        return try structured_query.PerfettoSqlStructuredQueryReader.init(&[_]u8{});
    }
    pub inline fn getDimensionUniqueness(self: *const TraceMetricV2TemplateSpecReader) TraceMetricV2Spec.DimensionUniqueness {
        return self._dimension_uniqueness;
    }
    pub inline fn getDisableAutoBundling(self: *const TraceMetricV2TemplateSpecReader) bool {
        return self._disable_auto_bundling;
    }
};
const TraceMetricV2BundleWire = struct {
    const BUNDLE_ID_WIRE: gremlin.ProtoWireNumber = 1;
    const ROW_WIRE: gremlin.ProtoWireNumber = 2;
    const SPECS_WIRE: gremlin.ProtoWireNumber = 3;
    const INTERNED_DIMENSION_BUNDLES_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TraceMetricV2Bundle = struct {
    // nested structs
    const RowWire = struct {
        const VALUES_WIRE: gremlin.ProtoWireNumber = 1;
        const DIMENSION_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Row = struct {
        // nested structs
        const ValueWire = struct {
            const NULL_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
            const DOUBLE_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const Value = struct {
            // nested structs
            pub const Null = struct {
                pub fn calcProtobufSize(_: *const TraceMetricV2Bundle.Row.Value.Null) usize {
                    return 0;
                }
                pub fn encode(self: *const TraceMetricV2Bundle.Row.Value.Null, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(_: *const TraceMetricV2Bundle.Row.Value.Null, _: *gremlin.Writer) void {}
            };
            pub const NullReader = struct {
                buf: gremlin.Reader,
                pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.Row.Value.NullReader {
                    const buf = gremlin.Reader.init(src);
                    return TraceMetricV2Bundle.Row.Value.NullReader{ .buf = buf };
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
            };
            // fields
            null_value: ?TraceMetricV2Bundle.Row.Value.Null = null,
            double_value: f64 = 0.0,
            pub fn calcProtobufSize(self: *const TraceMetricV2Bundle.Row.Value) usize {
                var res: usize = 0;
                if (self.null_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.ValueWire.NULL_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.double_value != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.ValueWire.DOUBLE_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_value);
                }
                return res;
            }
            pub fn encode(self: *const TraceMetricV2Bundle.Row.Value, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceMetricV2Bundle.Row.Value, target: *gremlin.Writer) void {
                if (self.null_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(TraceMetricV2Bundle.Row.ValueWire.NULL_VALUE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.double_value != 0.0) {
                    target.appendFloat64(TraceMetricV2Bundle.Row.ValueWire.DOUBLE_VALUE_WIRE, self.double_value);
                }
            }
        };
        pub const ValueReader = struct {
            buf: gremlin.Reader,
            _null_value_buf: ?[]const u8 = null,
            _double_value: f64 = 0.0,
            pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.Row.ValueReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceMetricV2Bundle.Row.ValueReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceMetricV2Bundle.Row.ValueWire.NULL_VALUE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._null_value_buf = result.value;
                        },
                        TraceMetricV2Bundle.Row.ValueWire.DOUBLE_VALUE_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._double_value = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn getNullValue(self: *const TraceMetricV2Bundle.Row.ValueReader) gremlin.Error!TraceMetricV2Bundle.Row.Value.NullReader {
                if (self._null_value_buf) |buf| {
                    return try TraceMetricV2Bundle.Row.Value.NullReader.init(buf);
                }
                return try TraceMetricV2Bundle.Row.Value.NullReader.init(&[_]u8{});
            }
            pub inline fn getDoubleValue(self: *const TraceMetricV2Bundle.Row.ValueReader) f64 {
                return self._double_value;
            }
        };
        const DimensionWire = struct {
            const STRING_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
            const INT64_VALUE_WIRE: gremlin.ProtoWireNumber = 2;
            const DOUBLE_VALUE_WIRE: gremlin.ProtoWireNumber = 3;
            const NULL_VALUE_WIRE: gremlin.ProtoWireNumber = 4;
            const BOOL_VALUE_WIRE: gremlin.ProtoWireNumber = 5;
        };
        pub const Dimension = struct {
            // nested structs
            pub const Null = struct {
                pub fn calcProtobufSize(_: *const TraceMetricV2Bundle.Row.Dimension.Null) usize {
                    return 0;
                }
                pub fn encode(self: *const TraceMetricV2Bundle.Row.Dimension.Null, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                    const size = self.calcProtobufSize();
                    if (size == 0) {
                        return &[_]u8{};
                    }
                    const buf = try allocator.alloc(u8, self.calcProtobufSize());
                    var writer = gremlin.Writer.init(buf);
                    self.encodeTo(&writer);
                    return buf;
                }
                pub fn encodeTo(_: *const TraceMetricV2Bundle.Row.Dimension.Null, _: *gremlin.Writer) void {}
            };
            pub const NullReader = struct {
                buf: gremlin.Reader,
                pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.Row.Dimension.NullReader {
                    const buf = gremlin.Reader.init(src);
                    return TraceMetricV2Bundle.Row.Dimension.NullReader{ .buf = buf };
                }
                pub fn sourceBytes(self: *const @This()) []const u8 {
                    return self.buf.buf;
                }
            };
            // fields
            string_value: ?[]const u8 = null,
            int64_value: i64 = 0,
            double_value: f64 = 0.0,
            null_value: ?TraceMetricV2Bundle.Row.Dimension.Null = null,
            bool_value: bool = false,
            pub fn calcProtobufSize(self: *const TraceMetricV2Bundle.Row.Dimension) usize {
                var res: usize = 0;
                if (self.string_value) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.DimensionWire.STRING_VALUE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.int64_value != 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.DimensionWire.INT64_VALUE_WIRE) + gremlin.sizes.sizeI64(self.int64_value);
                }
                if (self.double_value != 0.0) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.DimensionWire.DOUBLE_VALUE_WIRE) + gremlin.sizes.sizeDouble(self.double_value);
                }
                if (self.null_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.DimensionWire.NULL_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.bool_value != false) {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.Row.DimensionWire.BOOL_VALUE_WIRE) + gremlin.sizes.sizeBool(self.bool_value);
                }
                return res;
            }
            pub fn encode(self: *const TraceMetricV2Bundle.Row.Dimension, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceMetricV2Bundle.Row.Dimension, target: *gremlin.Writer) void {
                if (self.string_value) |v| {
                    if (v.len > 0) {
                        target.appendBytes(TraceMetricV2Bundle.Row.DimensionWire.STRING_VALUE_WIRE, v);
                    }
                }
                if (self.int64_value != 0) {
                    target.appendInt64(TraceMetricV2Bundle.Row.DimensionWire.INT64_VALUE_WIRE, self.int64_value);
                }
                if (self.double_value != 0.0) {
                    target.appendFloat64(TraceMetricV2Bundle.Row.DimensionWire.DOUBLE_VALUE_WIRE, self.double_value);
                }
                if (self.null_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(TraceMetricV2Bundle.Row.DimensionWire.NULL_VALUE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.bool_value != false) {
                    target.appendBool(TraceMetricV2Bundle.Row.DimensionWire.BOOL_VALUE_WIRE, self.bool_value);
                }
            }
        };
        pub const DimensionReader = struct {
            buf: gremlin.Reader,
            _string_value: ?[]const u8 = null,
            _int64_value: i64 = 0,
            _double_value: f64 = 0.0,
            _null_value_buf: ?[]const u8 = null,
            _bool_value: bool = false,
            pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.Row.DimensionReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceMetricV2Bundle.Row.DimensionReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceMetricV2Bundle.Row.DimensionWire.STRING_VALUE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._string_value = result.value;
                        },
                        TraceMetricV2Bundle.Row.DimensionWire.INT64_VALUE_WIRE => {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._int64_value = result.value;
                        },
                        TraceMetricV2Bundle.Row.DimensionWire.DOUBLE_VALUE_WIRE => {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._double_value = result.value;
                        },
                        TraceMetricV2Bundle.Row.DimensionWire.NULL_VALUE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._null_value_buf = result.value;
                        },
                        TraceMetricV2Bundle.Row.DimensionWire.BOOL_VALUE_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._bool_value = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getStringValue(self: *const TraceMetricV2Bundle.Row.DimensionReader) []const u8 {
                return self._string_value orelse &[_]u8{};
            }
            pub inline fn getInt64Value(self: *const TraceMetricV2Bundle.Row.DimensionReader) i64 {
                return self._int64_value;
            }
            pub inline fn getDoubleValue(self: *const TraceMetricV2Bundle.Row.DimensionReader) f64 {
                return self._double_value;
            }
            pub fn getNullValue(self: *const TraceMetricV2Bundle.Row.DimensionReader) gremlin.Error!TraceMetricV2Bundle.Row.Dimension.NullReader {
                if (self._null_value_buf) |buf| {
                    return try TraceMetricV2Bundle.Row.Dimension.NullReader.init(buf);
                }
                return try TraceMetricV2Bundle.Row.Dimension.NullReader.init(&[_]u8{});
            }
            pub inline fn getBoolValue(self: *const TraceMetricV2Bundle.Row.DimensionReader) bool {
                return self._bool_value;
            }
        };
        // fields
        values: ?[]const ?TraceMetricV2Bundle.Row.Value = null,
        dimension: ?[]const ?TraceMetricV2Bundle.Row.Dimension = null,
        pub fn calcProtobufSize(self: *const TraceMetricV2Bundle.Row) usize {
            var res: usize = 0;
            if (self.values) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.RowWire.VALUES_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.dimension) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.RowWire.DIMENSION_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceMetricV2Bundle.Row, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceMetricV2Bundle.Row, target: *gremlin.Writer) void {
            if (self.values) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TraceMetricV2Bundle.RowWire.VALUES_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TraceMetricV2Bundle.RowWire.VALUES_WIRE, 0);
                    }
                }
            }
            if (self.dimension) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TraceMetricV2Bundle.RowWire.DIMENSION_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TraceMetricV2Bundle.RowWire.DIMENSION_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const RowReader = struct {
        buf: gremlin.Reader,
        _values_offset: ?usize = null,
        _values_last_offset: ?usize = null,
        _values_cnt: usize = 0,
        _dimension_offset: ?usize = null,
        _dimension_last_offset: ?usize = null,
        _dimension_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.RowReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceMetricV2Bundle.RowReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceMetricV2Bundle.RowWire.VALUES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._values_offset == null) {
                            res._values_offset = offset - result.size;
                        }
                        res._values_last_offset = offset;
                        res._values_cnt += 1;
                    },
                    TraceMetricV2Bundle.RowWire.DIMENSION_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._dimension_offset == null) {
                            res._dimension_offset = offset - result.size;
                        }
                        res._dimension_last_offset = offset;
                        res._dimension_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn valuesCount(self: *const TraceMetricV2Bundle.RowReader) usize {
            return self._values_cnt;
        }
        pub fn valuesNext(self: *TraceMetricV2Bundle.RowReader) ?TraceMetricV2Bundle.Row.ValueReader {
            if (self._values_offset == null) return null;
            const current_offset = self._values_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TraceMetricV2Bundle.Row.ValueReader.init(result.value) catch return null;
            if (self._values_last_offset != null and current_offset >= self._values_last_offset.?) {
                self._values_offset = null;
                return msg;
            }
            if (self._values_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._values_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceMetricV2Bundle.RowWire.VALUES_WIRE) {
                    self._values_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._values_offset = null;
            return msg;
        }
        pub fn dimensionCount(self: *const TraceMetricV2Bundle.RowReader) usize {
            return self._dimension_cnt;
        }
        pub fn dimensionNext(self: *TraceMetricV2Bundle.RowReader) ?TraceMetricV2Bundle.Row.DimensionReader {
            if (self._dimension_offset == null) return null;
            const current_offset = self._dimension_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TraceMetricV2Bundle.Row.DimensionReader.init(result.value) catch return null;
            if (self._dimension_last_offset != null and current_offset >= self._dimension_last_offset.?) {
                self._dimension_offset = null;
                return msg;
            }
            if (self._dimension_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._dimension_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceMetricV2Bundle.RowWire.DIMENSION_WIRE) {
                    self._dimension_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._dimension_offset = null;
            return msg;
        }
    };
    const InternedDimensionBundleWire = struct {
        const INTERNED_DIMENSION_ROWS_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const InternedDimensionBundle = struct {
        // nested structs
        const InternedDimensionRowWire = struct {
            const KEY_DIMENSION_VALUE_WIRE: gremlin.ProtoWireNumber = 1;
            const INTERNED_DIMENSION_VALUES_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const InternedDimensionRow = struct {
            // fields
            key_dimension_value: ?TraceMetricV2Bundle.Row.Dimension = null,
            interned_dimension_values: ?[]const ?TraceMetricV2Bundle.Row.Dimension = null,
            pub fn calcProtobufSize(self: *const TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRow) usize {
                var res: usize = 0;
                if (self.key_dimension_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.KEY_DIMENSION_VALUE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.interned_dimension_values) |arr| {
                    for (arr) |maybe_v| {
                        res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.INTERNED_DIMENSION_VALUES_WIRE);
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            res += gremlin.sizes.sizeUsize(size) + size;
                        } else {
                            res += gremlin.sizes.sizeUsize(0);
                        }
                    }
                }
                return res;
            }
            pub fn encode(self: *const TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRow, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRow, target: *gremlin.Writer) void {
                if (self.key_dimension_value) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.KEY_DIMENSION_VALUE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.interned_dimension_values) |arr| {
                    for (arr) |maybe_v| {
                        if (maybe_v) |v| {
                            const size = v.calcProtobufSize();
                            target.appendBytesTag(TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.INTERNED_DIMENSION_VALUES_WIRE, size);
                            v.encodeTo(target);
                        } else {
                            target.appendBytesTag(TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.INTERNED_DIMENSION_VALUES_WIRE, 0);
                        }
                    }
                }
            }
        };
        pub const InternedDimensionRowReader = struct {
            buf: gremlin.Reader,
            _key_dimension_value_buf: ?[]const u8 = null,
            _interned_dimension_values_offset: ?usize = null,
            _interned_dimension_values_last_offset: ?usize = null,
            _interned_dimension_values_cnt: usize = 0,
            pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader {
                const buf = gremlin.Reader.init(src);
                var res = TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.KEY_DIMENSION_VALUE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._key_dimension_value_buf = result.value;
                        },
                        TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.INTERNED_DIMENSION_VALUES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            if (res._interned_dimension_values_offset == null) {
                                res._interned_dimension_values_offset = offset - result.size;
                            }
                            res._interned_dimension_values_last_offset = offset;
                            res._interned_dimension_values_cnt += 1;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn getKeyDimensionValue(self: *const TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader) gremlin.Error!TraceMetricV2Bundle.Row.DimensionReader {
                if (self._key_dimension_value_buf) |buf| {
                    return try TraceMetricV2Bundle.Row.DimensionReader.init(buf);
                }
                return try TraceMetricV2Bundle.Row.DimensionReader.init(&[_]u8{});
            }
            pub fn internedDimensionValuesCount(self: *const TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader) usize {
                return self._interned_dimension_values_cnt;
            }
            pub fn internedDimensionValuesNext(self: *TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader) ?TraceMetricV2Bundle.Row.DimensionReader {
                if (self._interned_dimension_values_offset == null) return null;
                const current_offset = self._interned_dimension_values_offset.?;
                const result = self.buf.readBytes(current_offset) catch return null;
                const msg = TraceMetricV2Bundle.Row.DimensionReader.init(result.value) catch return null;
                if (self._interned_dimension_values_last_offset != null and current_offset >= self._interned_dimension_values_last_offset.?) {
                    self._interned_dimension_values_offset = null;
                    return msg;
                }
                if (self._interned_dimension_values_last_offset == null) unreachable;
                var next_offset = current_offset + result.size;
                const max_offset = self._interned_dimension_values_last_offset.?;
                while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                    const tag = self.buf.readTagAt(next_offset) catch break;
                    next_offset += tag.size;
                    if (tag.number == TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowWire.INTERNED_DIMENSION_VALUES_WIRE) {
                        self._interned_dimension_values_offset = next_offset;
                        return msg;
                    } else {
                        next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                    }
                }
                self._interned_dimension_values_offset = null;
                return msg;
            }
        };
        // fields
        interned_dimension_rows: ?[]const ?TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRow = null,
        pub fn calcProtobufSize(self: *const TraceMetricV2Bundle.InternedDimensionBundle) usize {
            var res: usize = 0;
            if (self.interned_dimension_rows) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceMetricV2Bundle.InternedDimensionBundleWire.INTERNED_DIMENSION_ROWS_WIRE);
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        res += gremlin.sizes.sizeUsize(size) + size;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceMetricV2Bundle.InternedDimensionBundle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceMetricV2Bundle.InternedDimensionBundle, target: *gremlin.Writer) void {
            if (self.interned_dimension_rows) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        const size = v.calcProtobufSize();
                        target.appendBytesTag(TraceMetricV2Bundle.InternedDimensionBundleWire.INTERNED_DIMENSION_ROWS_WIRE, size);
                        v.encodeTo(target);
                    } else {
                        target.appendBytesTag(TraceMetricV2Bundle.InternedDimensionBundleWire.INTERNED_DIMENSION_ROWS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const InternedDimensionBundleReader = struct {
        buf: gremlin.Reader,
        _interned_dimension_rows_offset: ?usize = null,
        _interned_dimension_rows_last_offset: ?usize = null,
        _interned_dimension_rows_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!TraceMetricV2Bundle.InternedDimensionBundleReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceMetricV2Bundle.InternedDimensionBundleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceMetricV2Bundle.InternedDimensionBundleWire.INTERNED_DIMENSION_ROWS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._interned_dimension_rows_offset == null) {
                            res._interned_dimension_rows_offset = offset - result.size;
                        }
                        res._interned_dimension_rows_last_offset = offset;
                        res._interned_dimension_rows_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn internedDimensionRowsCount(self: *const TraceMetricV2Bundle.InternedDimensionBundleReader) usize {
            return self._interned_dimension_rows_cnt;
        }
        pub fn internedDimensionRowsNext(self: *TraceMetricV2Bundle.InternedDimensionBundleReader) ?TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader {
            if (self._interned_dimension_rows_offset == null) return null;
            const current_offset = self._interned_dimension_rows_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            const msg = TraceMetricV2Bundle.InternedDimensionBundle.InternedDimensionRowReader.init(result.value) catch return null;
            if (self._interned_dimension_rows_last_offset != null and current_offset >= self._interned_dimension_rows_last_offset.?) {
                self._interned_dimension_rows_offset = null;
                return msg;
            }
            if (self._interned_dimension_rows_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._interned_dimension_rows_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceMetricV2Bundle.InternedDimensionBundleWire.INTERNED_DIMENSION_ROWS_WIRE) {
                    self._interned_dimension_rows_offset = next_offset;
                    return msg;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._interned_dimension_rows_offset = null;
            return msg;
        }
    };
    // fields
    bundle_id: ?[]const u8 = null,
    row: ?[]const ?TraceMetricV2Bundle.Row = null,
    specs: ?[]const ?TraceMetricV2Spec = null,
    interned_dimension_bundles: ?[]const ?TraceMetricV2Bundle.InternedDimensionBundle = null,
    pub fn calcProtobufSize(self: *const TraceMetricV2Bundle) usize {
        var res: usize = 0;
        if (self.bundle_id) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2BundleWire.BUNDLE_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.row) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2BundleWire.ROW_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2BundleWire.SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.interned_dimension_bundles) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceMetricV2BundleWire.INTERNED_DIMENSION_BUNDLES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceMetricV2Bundle, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceMetricV2Bundle, target: *gremlin.Writer) void {
        if (self.bundle_id) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceMetricV2BundleWire.BUNDLE_ID_WIRE, v);
            }
        }
        if (self.row) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2BundleWire.ROW_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2BundleWire.ROW_WIRE, 0);
                }
            }
        }
        if (self.specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2BundleWire.SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2BundleWire.SPECS_WIRE, 0);
                }
            }
        }
        if (self.interned_dimension_bundles) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceMetricV2BundleWire.INTERNED_DIMENSION_BUNDLES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceMetricV2BundleWire.INTERNED_DIMENSION_BUNDLES_WIRE, 0);
                }
            }
        }
    }
};
pub const TraceMetricV2BundleReader = struct {
    buf: gremlin.Reader,
    _bundle_id: ?[]const u8 = null,
    _row_offset: ?usize = null,
    _row_last_offset: ?usize = null,
    _row_cnt: usize = 0,
    _specs_offset: ?usize = null,
    _specs_last_offset: ?usize = null,
    _specs_cnt: usize = 0,
    _interned_dimension_bundles_offset: ?usize = null,
    _interned_dimension_bundles_last_offset: ?usize = null,
    _interned_dimension_bundles_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TraceMetricV2BundleReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceMetricV2BundleReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceMetricV2BundleWire.BUNDLE_ID_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._bundle_id = result.value;
                },
                TraceMetricV2BundleWire.ROW_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._row_offset == null) {
                        res._row_offset = offset - result.size;
                    }
                    res._row_last_offset = offset;
                    res._row_cnt += 1;
                },
                TraceMetricV2BundleWire.SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._specs_offset == null) {
                        res._specs_offset = offset - result.size;
                    }
                    res._specs_last_offset = offset;
                    res._specs_cnt += 1;
                },
                TraceMetricV2BundleWire.INTERNED_DIMENSION_BUNDLES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._interned_dimension_bundles_offset == null) {
                        res._interned_dimension_bundles_offset = offset - result.size;
                    }
                    res._interned_dimension_bundles_last_offset = offset;
                    res._interned_dimension_bundles_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getBundleId(self: *const TraceMetricV2BundleReader) []const u8 {
        return self._bundle_id orelse &[_]u8{};
    }
    pub fn rowCount(self: *const TraceMetricV2BundleReader) usize {
        return self._row_cnt;
    }
    pub fn rowNext(self: *TraceMetricV2BundleReader) ?TraceMetricV2Bundle.RowReader {
        if (self._row_offset == null) return null;
        const current_offset = self._row_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Bundle.RowReader.init(result.value) catch return null;
        if (self._row_last_offset != null and current_offset >= self._row_last_offset.?) {
            self._row_offset = null;
            return msg;
        }
        if (self._row_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._row_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2BundleWire.ROW_WIRE) {
                self._row_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._row_offset = null;
        return msg;
    }
    pub fn specsCount(self: *const TraceMetricV2BundleReader) usize {
        return self._specs_cnt;
    }
    pub fn specsNext(self: *TraceMetricV2BundleReader) ?TraceMetricV2SpecReader {
        if (self._specs_offset == null) return null;
        const current_offset = self._specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2SpecReader.init(result.value) catch return null;
        if (self._specs_last_offset != null and current_offset >= self._specs_last_offset.?) {
            self._specs_offset = null;
            return msg;
        }
        if (self._specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2BundleWire.SPECS_WIRE) {
                self._specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._specs_offset = null;
        return msg;
    }
    pub fn internedDimensionBundlesCount(self: *const TraceMetricV2BundleReader) usize {
        return self._interned_dimension_bundles_cnt;
    }
    pub fn internedDimensionBundlesNext(self: *TraceMetricV2BundleReader) ?TraceMetricV2Bundle.InternedDimensionBundleReader {
        if (self._interned_dimension_bundles_offset == null) return null;
        const current_offset = self._interned_dimension_bundles_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceMetricV2Bundle.InternedDimensionBundleReader.init(result.value) catch return null;
        if (self._interned_dimension_bundles_last_offset != null and current_offset >= self._interned_dimension_bundles_last_offset.?) {
            self._interned_dimension_bundles_offset = null;
            return msg;
        }
        if (self._interned_dimension_bundles_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._interned_dimension_bundles_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceMetricV2BundleWire.INTERNED_DIMENSION_BUNDLES_WIRE) {
                self._interned_dimension_bundles_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._interned_dimension_bundles_offset = null;
        return msg;
    }
};
