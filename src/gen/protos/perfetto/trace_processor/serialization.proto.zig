// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
// structs
const SerializedTraceProcessorWire = struct {
    const PACKET_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SerializedTraceProcessor = struct {
    // fields
    packet: ?[]const ?SerializedTraceProcessorPacket = null,
    pub fn calcProtobufSize(self: *const SerializedTraceProcessor) usize {
        var res: usize = 0;
        if (self.packet) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(SerializedTraceProcessorWire.PACKET_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const SerializedTraceProcessor, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SerializedTraceProcessor, target: *gremlin.Writer) void {
        if (self.packet) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(SerializedTraceProcessorWire.PACKET_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(SerializedTraceProcessorWire.PACKET_WIRE, 0);
                }
            }
        }
    }
};
pub const SerializedTraceProcessorReader = struct {
    buf: gremlin.Reader,
    _packet_offset: ?usize = null,
    _packet_last_offset: ?usize = null,
    _packet_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!SerializedTraceProcessorReader {
        const buf = gremlin.Reader.init(src);
        var res = SerializedTraceProcessorReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SerializedTraceProcessorWire.PACKET_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._packet_offset == null) {
                        res._packet_offset = offset - result.size;
                    }
                    res._packet_last_offset = offset;
                    res._packet_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn packetCount(self: *const SerializedTraceProcessorReader) usize {
        return self._packet_cnt;
    }
    pub fn packetNext(self: *SerializedTraceProcessorReader) ?SerializedTraceProcessorPacketReader {
        if (self._packet_offset == null) return null;
        const current_offset = self._packet_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = SerializedTraceProcessorPacketReader.init(result.value) catch return null;
        if (self._packet_last_offset != null and current_offset >= self._packet_last_offset.?) {
            self._packet_offset = null;
            return msg;
        }
        if (self._packet_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._packet_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == SerializedTraceProcessorWire.PACKET_WIRE) {
                self._packet_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._packet_offset = null;
        return msg;
    }
};
const SerializedTraceProcessorPacketWire = struct {
    const COLUMN_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const SerializedTraceProcessorPacket = struct {
    // fields
    column: ?SerializedColumn = null,
    pub fn calcProtobufSize(self: *const SerializedTraceProcessorPacket) usize {
        var res: usize = 0;
        if (self.column) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SerializedTraceProcessorPacketWire.COLUMN_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const SerializedTraceProcessorPacket, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SerializedTraceProcessorPacket, target: *gremlin.Writer) void {
        if (self.column) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SerializedTraceProcessorPacketWire.COLUMN_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const SerializedTraceProcessorPacketReader = struct {
    buf: gremlin.Reader,
    _column_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!SerializedTraceProcessorPacketReader {
        const buf = gremlin.Reader.init(src);
        var res = SerializedTraceProcessorPacketReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SerializedTraceProcessorPacketWire.COLUMN_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._column_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getColumn(self: *const SerializedTraceProcessorPacketReader) gremlin.Error!SerializedColumnReader {
        if (self._column_buf) |buf| {
            return try SerializedColumnReader.init(buf);
        }
        return try SerializedColumnReader.init(&[_]u8{});
    }
};
const SerializedColumnWire = struct {
    const TABLE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const COLUMN_NAME_WIRE: gremlin.ProtoWireNumber = 2;
    const STORAGE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const SerializedColumn = struct {
    // nested structs
    const BitVectorWire = struct {
        const WORDS_WIRE: gremlin.ProtoWireNumber = 1;
        const COUNTS_WIRE: gremlin.ProtoWireNumber = 2;
        const SIZE_WIRE: gremlin.ProtoWireNumber = 3;
    };
    pub const BitVector = struct {
        // fields
        words: ?[]const u8 = null,
        counts: ?[]const u8 = null,
        size: u32 = 0,
        pub fn calcProtobufSize(self: *const SerializedColumn.BitVector) usize {
            var res: usize = 0;
            if (self.words) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.BitVectorWire.WORDS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.counts) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.BitVectorWire.COUNTS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.size != 0) {
                res += gremlin.sizes.sizeWireNumber(SerializedColumn.BitVectorWire.SIZE_WIRE) + gremlin.sizes.sizeU32(self.size);
            }
            return res;
        }
        pub fn encode(self: *const SerializedColumn.BitVector, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SerializedColumn.BitVector, target: *gremlin.Writer) void {
            if (self.words) |v| {
                if (v.len > 0) {
                    target.appendBytes(SerializedColumn.BitVectorWire.WORDS_WIRE, v);
                }
            }
            if (self.counts) |v| {
                if (v.len > 0) {
                    target.appendBytes(SerializedColumn.BitVectorWire.COUNTS_WIRE, v);
                }
            }
            if (self.size != 0) {
                target.appendUint32(SerializedColumn.BitVectorWire.SIZE_WIRE, self.size);
            }
        }
    };
    pub const BitVectorReader = struct {
        buf: gremlin.Reader,
        _words: ?[]const u8 = null,
        _counts: ?[]const u8 = null,
        _size: u32 = 0,
        pub fn init(src: []const u8) gremlin.Error!SerializedColumn.BitVectorReader {
            const buf = gremlin.Reader.init(src);
            var res = SerializedColumn.BitVectorReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SerializedColumn.BitVectorWire.WORDS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._words = result.value;
                    },
                    SerializedColumn.BitVectorWire.COUNTS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._counts = result.value;
                    },
                    SerializedColumn.BitVectorWire.SIZE_WIRE => {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._size = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getWords(self: *const SerializedColumn.BitVectorReader) []const u8 {
            return self._words orelse &[_]u8{};
        }
        pub inline fn getCounts(self: *const SerializedColumn.BitVectorReader) []const u8 {
            return self._counts orelse &[_]u8{};
        }
        pub inline fn getSize(self: *const SerializedColumn.BitVectorReader) u32 {
            return self._size;
        }
    };
    const StorageWire = struct {
        const DUMMY_STORAGE_WIRE: gremlin.ProtoWireNumber = 1;
        const ID_STORAGE_WIRE: gremlin.ProtoWireNumber = 2;
        const NUMERIC_STORAGE_WIRE: gremlin.ProtoWireNumber = 3;
        const SET_ID_STORAGE_WIRE: gremlin.ProtoWireNumber = 4;
        const STRING_STORAGE_WIRE: gremlin.ProtoWireNumber = 5;
        const NULL_OVERLAY_WIRE: gremlin.ProtoWireNumber = 6;
        const ARRANGEMENT_OVERLAY_WIRE: gremlin.ProtoWireNumber = 7;
        const SELECTOR_OVERLAY_WIRE: gremlin.ProtoWireNumber = 8;
        const DENSE_NULL_OVERLAY_WIRE: gremlin.ProtoWireNumber = 9;
    };
    pub const Storage = struct {
        // nested structs
        pub const DummyStorage = struct {
            pub fn calcProtobufSize(_: *const SerializedColumn.Storage.DummyStorage) usize {
                return 0;
            }
            pub fn encode(self: *const SerializedColumn.Storage.DummyStorage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(_: *const SerializedColumn.Storage.DummyStorage, _: *gremlin.Writer) void {}
        };
        pub const DummyStorageReader = struct {
            buf: gremlin.Reader,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.DummyStorageReader {
                const buf = gremlin.Reader.init(src);
                return SerializedColumn.Storage.DummyStorageReader{ .buf = buf };
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
        };
        const IdStorageWire = struct {
            const SIZE_WIRE: gremlin.ProtoWireNumber = 1;
        };
        pub const IdStorage = struct {
            // fields
            size: u64 = 0,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.IdStorage) usize {
                var res: usize = 0;
                if (self.size != 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.IdStorageWire.SIZE_WIRE) + gremlin.sizes.sizeU64(self.size);
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.IdStorage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.IdStorage, target: *gremlin.Writer) void {
                if (self.size != 0) {
                    target.appendUint64(SerializedColumn.Storage.IdStorageWire.SIZE_WIRE, self.size);
                }
            }
        };
        pub const IdStorageReader = struct {
            buf: gremlin.Reader,
            _size: u64 = 0,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.IdStorageReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.IdStorageReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.IdStorageWire.SIZE_WIRE => {
                            const result = try buf.readUInt64(offset);
                            offset += result.size;
                            res._size = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getSize(self: *const SerializedColumn.Storage.IdStorageReader) u64 {
                return self._size;
            }
        };
        const NumericStorageWire = struct {
            const VALUES_WIRE: gremlin.ProtoWireNumber = 1;
            const IS_SORTED_WIRE: gremlin.ProtoWireNumber = 2;
            const COLUMN_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
        };
        pub const NumericStorage = struct {
            // fields
            values: ?[]const u8 = null,
            is_sorted: bool = false,
            column_type: u32 = 0,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.NumericStorage) usize {
                var res: usize = 0;
                if (self.values) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.NumericStorageWire.VALUES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.is_sorted != false) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.NumericStorageWire.IS_SORTED_WIRE) + gremlin.sizes.sizeBool(self.is_sorted);
                }
                if (self.column_type != 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.NumericStorageWire.COLUMN_TYPE_WIRE) + gremlin.sizes.sizeU32(self.column_type);
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.NumericStorage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.NumericStorage, target: *gremlin.Writer) void {
                if (self.values) |v| {
                    if (v.len > 0) {
                        target.appendBytes(SerializedColumn.Storage.NumericStorageWire.VALUES_WIRE, v);
                    }
                }
                if (self.is_sorted != false) {
                    target.appendBool(SerializedColumn.Storage.NumericStorageWire.IS_SORTED_WIRE, self.is_sorted);
                }
                if (self.column_type != 0) {
                    target.appendUint32(SerializedColumn.Storage.NumericStorageWire.COLUMN_TYPE_WIRE, self.column_type);
                }
            }
        };
        pub const NumericStorageReader = struct {
            buf: gremlin.Reader,
            _values: ?[]const u8 = null,
            _is_sorted: bool = false,
            _column_type: u32 = 0,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.NumericStorageReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.NumericStorageReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.NumericStorageWire.VALUES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._values = result.value;
                        },
                        SerializedColumn.Storage.NumericStorageWire.IS_SORTED_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._is_sorted = result.value;
                        },
                        SerializedColumn.Storage.NumericStorageWire.COLUMN_TYPE_WIRE => {
                            const result = try buf.readUInt32(offset);
                            offset += result.size;
                            res._column_type = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getValues(self: *const SerializedColumn.Storage.NumericStorageReader) []const u8 {
                return self._values orelse &[_]u8{};
            }
            pub inline fn getIsSorted(self: *const SerializedColumn.Storage.NumericStorageReader) bool {
                return self._is_sorted;
            }
            pub inline fn getColumnType(self: *const SerializedColumn.Storage.NumericStorageReader) u32 {
                return self._column_type;
            }
        };
        const SetIdStorageWire = struct {
            const VALUES_WIRE: gremlin.ProtoWireNumber = 1;
        };
        pub const SetIdStorage = struct {
            // fields
            values: ?[]const u8 = null,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.SetIdStorage) usize {
                var res: usize = 0;
                if (self.values) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.SetIdStorageWire.VALUES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.SetIdStorage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.SetIdStorage, target: *gremlin.Writer) void {
                if (self.values) |v| {
                    if (v.len > 0) {
                        target.appendBytes(SerializedColumn.Storage.SetIdStorageWire.VALUES_WIRE, v);
                    }
                }
            }
        };
        pub const SetIdStorageReader = struct {
            buf: gremlin.Reader,
            _values: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.SetIdStorageReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.SetIdStorageReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.SetIdStorageWire.VALUES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._values = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getValues(self: *const SerializedColumn.Storage.SetIdStorageReader) []const u8 {
                return self._values orelse &[_]u8{};
            }
        };
        const StringStorageWire = struct {
            const VALUES_WIRE: gremlin.ProtoWireNumber = 1;
            const IS_SORTED_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const StringStorage = struct {
            // fields
            values: ?[]const u8 = null,
            is_sorted: bool = false,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.StringStorage) usize {
                var res: usize = 0;
                if (self.values) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.StringStorageWire.VALUES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.is_sorted != false) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.StringStorageWire.IS_SORTED_WIRE) + gremlin.sizes.sizeBool(self.is_sorted);
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.StringStorage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.StringStorage, target: *gremlin.Writer) void {
                if (self.values) |v| {
                    if (v.len > 0) {
                        target.appendBytes(SerializedColumn.Storage.StringStorageWire.VALUES_WIRE, v);
                    }
                }
                if (self.is_sorted != false) {
                    target.appendBool(SerializedColumn.Storage.StringStorageWire.IS_SORTED_WIRE, self.is_sorted);
                }
            }
        };
        pub const StringStorageReader = struct {
            buf: gremlin.Reader,
            _values: ?[]const u8 = null,
            _is_sorted: bool = false,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.StringStorageReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.StringStorageReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.StringStorageWire.VALUES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._values = result.value;
                        },
                        SerializedColumn.Storage.StringStorageWire.IS_SORTED_WIRE => {
                            const result = try buf.readBool(offset);
                            offset += result.size;
                            res._is_sorted = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getValues(self: *const SerializedColumn.Storage.StringStorageReader) []const u8 {
                return self._values orelse &[_]u8{};
            }
            pub inline fn getIsSorted(self: *const SerializedColumn.Storage.StringStorageReader) bool {
                return self._is_sorted;
            }
        };
        const NullOverlayWire = struct {
            const BIT_VECTOR_WIRE: gremlin.ProtoWireNumber = 1;
            const STORAGE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const NullOverlay = struct {
            // fields
            bit_vector: ?SerializedColumn.BitVector = null,
            storage: ?SerializedColumn.Storage = null,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.NullOverlay) usize {
                var res: usize = 0;
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.NullOverlayWire.BIT_VECTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.NullOverlayWire.STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.NullOverlay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.NullOverlay, target: *gremlin.Writer) void {
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.NullOverlayWire.BIT_VECTOR_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.NullOverlayWire.STORAGE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const NullOverlayReader = struct {
            buf: gremlin.Reader,
            _bit_vector_buf: ?[]const u8 = null,
            _storage_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.NullOverlayReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.NullOverlayReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.NullOverlayWire.BIT_VECTOR_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._bit_vector_buf = result.value;
                        },
                        SerializedColumn.Storage.NullOverlayWire.STORAGE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._storage_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn getBitVector(self: *const SerializedColumn.Storage.NullOverlayReader) gremlin.Error!SerializedColumn.BitVectorReader {
                if (self._bit_vector_buf) |buf| {
                    return try SerializedColumn.BitVectorReader.init(buf);
                }
                return try SerializedColumn.BitVectorReader.init(&[_]u8{});
            }
            pub fn getStorage(self: *const SerializedColumn.Storage.NullOverlayReader) gremlin.Error!SerializedColumn.StorageReader {
                if (self._storage_buf) |buf| {
                    return try SerializedColumn.StorageReader.init(buf);
                }
                return try SerializedColumn.StorageReader.init(&[_]u8{});
            }
        };
        const ArrangementOverlayWire = struct {
            const VALUES_WIRE: gremlin.ProtoWireNumber = 1;
            const STORAGE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const ArrangementOverlay = struct {
            // fields
            values: ?[]const u8 = null,
            storage: ?SerializedColumn.Storage = null,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.ArrangementOverlay) usize {
                var res: usize = 0;
                if (self.values) |v| {
                    if (v.len > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.ArrangementOverlayWire.VALUES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.ArrangementOverlayWire.STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.ArrangementOverlay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.ArrangementOverlay, target: *gremlin.Writer) void {
                if (self.values) |v| {
                    if (v.len > 0) {
                        target.appendBytes(SerializedColumn.Storage.ArrangementOverlayWire.VALUES_WIRE, v);
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.ArrangementOverlayWire.STORAGE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const ArrangementOverlayReader = struct {
            buf: gremlin.Reader,
            _values: ?[]const u8 = null,
            _storage_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.ArrangementOverlayReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.ArrangementOverlayReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.ArrangementOverlayWire.VALUES_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._values = result.value;
                        },
                        SerializedColumn.Storage.ArrangementOverlayWire.STORAGE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._storage_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getValues(self: *const SerializedColumn.Storage.ArrangementOverlayReader) []const u8 {
                return self._values orelse &[_]u8{};
            }
            pub fn getStorage(self: *const SerializedColumn.Storage.ArrangementOverlayReader) gremlin.Error!SerializedColumn.StorageReader {
                if (self._storage_buf) |buf| {
                    return try SerializedColumn.StorageReader.init(buf);
                }
                return try SerializedColumn.StorageReader.init(&[_]u8{});
            }
        };
        const SelectorOverlayWire = struct {
            const BIT_VECTOR_WIRE: gremlin.ProtoWireNumber = 1;
            const STORAGE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const SelectorOverlay = struct {
            // fields
            bit_vector: ?SerializedColumn.BitVector = null,
            storage: ?SerializedColumn.Storage = null,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.SelectorOverlay) usize {
                var res: usize = 0;
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.SelectorOverlayWire.BIT_VECTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.SelectorOverlayWire.STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.SelectorOverlay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.SelectorOverlay, target: *gremlin.Writer) void {
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.SelectorOverlayWire.BIT_VECTOR_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.SelectorOverlayWire.STORAGE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const SelectorOverlayReader = struct {
            buf: gremlin.Reader,
            _bit_vector_buf: ?[]const u8 = null,
            _storage_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.SelectorOverlayReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.SelectorOverlayReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.SelectorOverlayWire.BIT_VECTOR_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._bit_vector_buf = result.value;
                        },
                        SerializedColumn.Storage.SelectorOverlayWire.STORAGE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._storage_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn getBitVector(self: *const SerializedColumn.Storage.SelectorOverlayReader) gremlin.Error!SerializedColumn.BitVectorReader {
                if (self._bit_vector_buf) |buf| {
                    return try SerializedColumn.BitVectorReader.init(buf);
                }
                return try SerializedColumn.BitVectorReader.init(&[_]u8{});
            }
            pub fn getStorage(self: *const SerializedColumn.Storage.SelectorOverlayReader) gremlin.Error!SerializedColumn.StorageReader {
                if (self._storage_buf) |buf| {
                    return try SerializedColumn.StorageReader.init(buf);
                }
                return try SerializedColumn.StorageReader.init(&[_]u8{});
            }
        };
        const DenseNullOverlayWire = struct {
            const BIT_VECTOR_WIRE: gremlin.ProtoWireNumber = 1;
            const STORAGE_WIRE: gremlin.ProtoWireNumber = 2;
        };
        pub const DenseNullOverlay = struct {
            // fields
            bit_vector: ?SerializedColumn.BitVector = null,
            storage: ?SerializedColumn.Storage = null,
            pub fn calcProtobufSize(self: *const SerializedColumn.Storage.DenseNullOverlay) usize {
                var res: usize = 0;
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.DenseNullOverlayWire.BIT_VECTOR_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        res += gremlin.sizes.sizeWireNumber(SerializedColumn.Storage.DenseNullOverlayWire.STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                    }
                }
                return res;
            }
            pub fn encode(self: *const SerializedColumn.Storage.DenseNullOverlay, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const SerializedColumn.Storage.DenseNullOverlay, target: *gremlin.Writer) void {
                if (self.bit_vector) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.DenseNullOverlayWire.BIT_VECTOR_WIRE, size);
                        v.encodeTo(target);
                    }
                }
                if (self.storage) |v| {
                    const size = v.calcProtobufSize();
                    if (size > 0) {
                        target.appendBytesTag(SerializedColumn.Storage.DenseNullOverlayWire.STORAGE_WIRE, size);
                        v.encodeTo(target);
                    }
                }
            }
        };
        pub const DenseNullOverlayReader = struct {
            buf: gremlin.Reader,
            _bit_vector_buf: ?[]const u8 = null,
            _storage_buf: ?[]const u8 = null,
            pub fn init(src: []const u8) gremlin.Error!SerializedColumn.Storage.DenseNullOverlayReader {
                const buf = gremlin.Reader.init(src);
                var res = SerializedColumn.Storage.DenseNullOverlayReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        SerializedColumn.Storage.DenseNullOverlayWire.BIT_VECTOR_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._bit_vector_buf = result.value;
                        },
                        SerializedColumn.Storage.DenseNullOverlayWire.STORAGE_WIRE => {
                            const result = try buf.readBytes(offset);
                            offset += result.size;
                            res._storage_buf = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub fn getBitVector(self: *const SerializedColumn.Storage.DenseNullOverlayReader) gremlin.Error!SerializedColumn.BitVectorReader {
                if (self._bit_vector_buf) |buf| {
                    return try SerializedColumn.BitVectorReader.init(buf);
                }
                return try SerializedColumn.BitVectorReader.init(&[_]u8{});
            }
            pub fn getStorage(self: *const SerializedColumn.Storage.DenseNullOverlayReader) gremlin.Error!SerializedColumn.StorageReader {
                if (self._storage_buf) |buf| {
                    return try SerializedColumn.StorageReader.init(buf);
                }
                return try SerializedColumn.StorageReader.init(&[_]u8{});
            }
        };
        // fields
        dummy_storage: ?SerializedColumn.Storage.DummyStorage = null,
        id_storage: ?SerializedColumn.Storage.IdStorage = null,
        numeric_storage: ?SerializedColumn.Storage.NumericStorage = null,
        set_id_storage: ?SerializedColumn.Storage.SetIdStorage = null,
        string_storage: ?SerializedColumn.Storage.StringStorage = null,
        null_overlay: ?SerializedColumn.Storage.NullOverlay = null,
        arrangement_overlay: ?SerializedColumn.Storage.ArrangementOverlay = null,
        selector_overlay: ?SerializedColumn.Storage.SelectorOverlay = null,
        dense_null_overlay: ?SerializedColumn.Storage.DenseNullOverlay = null,
        pub fn calcProtobufSize(self: *const SerializedColumn.Storage) usize {
            var res: usize = 0;
            if (self.dummy_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.DUMMY_STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.id_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.ID_STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.numeric_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.NUMERIC_STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.set_id_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.SET_ID_STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.string_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.STRING_STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.null_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.NULL_OVERLAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.arrangement_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.ARRANGEMENT_OVERLAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.selector_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.SELECTOR_OVERLAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            if (self.dense_null_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(SerializedColumn.StorageWire.DENSE_NULL_OVERLAY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const SerializedColumn.Storage, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const SerializedColumn.Storage, target: *gremlin.Writer) void {
            if (self.dummy_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.DUMMY_STORAGE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.id_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.ID_STORAGE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.numeric_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.NUMERIC_STORAGE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.set_id_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.SET_ID_STORAGE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.string_storage) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.STRING_STORAGE_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.null_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.NULL_OVERLAY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.arrangement_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.ARRANGEMENT_OVERLAY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.selector_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.SELECTOR_OVERLAY_WIRE, size);
                    v.encodeTo(target);
                }
            }
            if (self.dense_null_overlay) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(SerializedColumn.StorageWire.DENSE_NULL_OVERLAY_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const StorageReader = struct {
        buf: gremlin.Reader,
        _dummy_storage_buf: ?[]const u8 = null,
        _id_storage_buf: ?[]const u8 = null,
        _numeric_storage_buf: ?[]const u8 = null,
        _set_id_storage_buf: ?[]const u8 = null,
        _string_storage_buf: ?[]const u8 = null,
        _null_overlay_buf: ?[]const u8 = null,
        _arrangement_overlay_buf: ?[]const u8 = null,
        _selector_overlay_buf: ?[]const u8 = null,
        _dense_null_overlay_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!SerializedColumn.StorageReader {
            const buf = gremlin.Reader.init(src);
            var res = SerializedColumn.StorageReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    SerializedColumn.StorageWire.DUMMY_STORAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._dummy_storage_buf = result.value;
                    },
                    SerializedColumn.StorageWire.ID_STORAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._id_storage_buf = result.value;
                    },
                    SerializedColumn.StorageWire.NUMERIC_STORAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._numeric_storage_buf = result.value;
                    },
                    SerializedColumn.StorageWire.SET_ID_STORAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._set_id_storage_buf = result.value;
                    },
                    SerializedColumn.StorageWire.STRING_STORAGE_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._string_storage_buf = result.value;
                    },
                    SerializedColumn.StorageWire.NULL_OVERLAY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._null_overlay_buf = result.value;
                    },
                    SerializedColumn.StorageWire.ARRANGEMENT_OVERLAY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._arrangement_overlay_buf = result.value;
                    },
                    SerializedColumn.StorageWire.SELECTOR_OVERLAY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._selector_overlay_buf = result.value;
                    },
                    SerializedColumn.StorageWire.DENSE_NULL_OVERLAY_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._dense_null_overlay_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getDummyStorage(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.DummyStorageReader {
            if (self._dummy_storage_buf) |buf| {
                return try SerializedColumn.Storage.DummyStorageReader.init(buf);
            }
            return try SerializedColumn.Storage.DummyStorageReader.init(&[_]u8{});
        }
        pub fn getIdStorage(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.IdStorageReader {
            if (self._id_storage_buf) |buf| {
                return try SerializedColumn.Storage.IdStorageReader.init(buf);
            }
            return try SerializedColumn.Storage.IdStorageReader.init(&[_]u8{});
        }
        pub fn getNumericStorage(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.NumericStorageReader {
            if (self._numeric_storage_buf) |buf| {
                return try SerializedColumn.Storage.NumericStorageReader.init(buf);
            }
            return try SerializedColumn.Storage.NumericStorageReader.init(&[_]u8{});
        }
        pub fn getSetIdStorage(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.SetIdStorageReader {
            if (self._set_id_storage_buf) |buf| {
                return try SerializedColumn.Storage.SetIdStorageReader.init(buf);
            }
            return try SerializedColumn.Storage.SetIdStorageReader.init(&[_]u8{});
        }
        pub fn getStringStorage(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.StringStorageReader {
            if (self._string_storage_buf) |buf| {
                return try SerializedColumn.Storage.StringStorageReader.init(buf);
            }
            return try SerializedColumn.Storage.StringStorageReader.init(&[_]u8{});
        }
        pub fn getNullOverlay(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.NullOverlayReader {
            if (self._null_overlay_buf) |buf| {
                return try SerializedColumn.Storage.NullOverlayReader.init(buf);
            }
            return try SerializedColumn.Storage.NullOverlayReader.init(&[_]u8{});
        }
        pub fn getArrangementOverlay(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.ArrangementOverlayReader {
            if (self._arrangement_overlay_buf) |buf| {
                return try SerializedColumn.Storage.ArrangementOverlayReader.init(buf);
            }
            return try SerializedColumn.Storage.ArrangementOverlayReader.init(&[_]u8{});
        }
        pub fn getSelectorOverlay(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.SelectorOverlayReader {
            if (self._selector_overlay_buf) |buf| {
                return try SerializedColumn.Storage.SelectorOverlayReader.init(buf);
            }
            return try SerializedColumn.Storage.SelectorOverlayReader.init(&[_]u8{});
        }
        pub fn getDenseNullOverlay(self: *const SerializedColumn.StorageReader) gremlin.Error!SerializedColumn.Storage.DenseNullOverlayReader {
            if (self._dense_null_overlay_buf) |buf| {
                return try SerializedColumn.Storage.DenseNullOverlayReader.init(buf);
            }
            return try SerializedColumn.Storage.DenseNullOverlayReader.init(&[_]u8{});
        }
    };
    // fields
    table_name: ?[]const u8 = null,
    column_name: ?[]const u8 = null,
    storage: ?SerializedColumn.Storage = null,
    pub fn calcProtobufSize(self: *const SerializedColumn) usize {
        var res: usize = 0;
        if (self.table_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SerializedColumnWire.TABLE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.column_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(SerializedColumnWire.COLUMN_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.storage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(SerializedColumnWire.STORAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const SerializedColumn, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const SerializedColumn, target: *gremlin.Writer) void {
        if (self.table_name) |v| {
            if (v.len > 0) {
                target.appendBytes(SerializedColumnWire.TABLE_NAME_WIRE, v);
            }
        }
        if (self.column_name) |v| {
            if (v.len > 0) {
                target.appendBytes(SerializedColumnWire.COLUMN_NAME_WIRE, v);
            }
        }
        if (self.storage) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(SerializedColumnWire.STORAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const SerializedColumnReader = struct {
    buf: gremlin.Reader,
    _table_name: ?[]const u8 = null,
    _column_name: ?[]const u8 = null,
    _storage_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!SerializedColumnReader {
        const buf = gremlin.Reader.init(src);
        var res = SerializedColumnReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                SerializedColumnWire.TABLE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._table_name = result.value;
                },
                SerializedColumnWire.COLUMN_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._column_name = result.value;
                },
                SerializedColumnWire.STORAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._storage_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTableName(self: *const SerializedColumnReader) []const u8 {
        return self._table_name orelse &[_]u8{};
    }
    pub inline fn getColumnName(self: *const SerializedColumnReader) []const u8 {
        return self._column_name orelse &[_]u8{};
    }
    pub fn getStorage(self: *const SerializedColumnReader) gremlin.Error!SerializedColumn.StorageReader {
        if (self._storage_buf) |buf| {
            return try SerializedColumn.StorageReader.init(buf);
        }
        return try SerializedColumn.StorageReader.init(&[_]u8{});
    }
};
