// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const metatrace_categories = @import("metatrace_categories.proto.zig");
const descriptor = @import("src/gen/protos/perfetto/common/descriptor.proto.zig");
const structured_query = @import("src/gen/protos/perfetto/perfetto_sql/structured_query.proto.zig");
const file = @import("src/gen/protos/perfetto/trace_summary/file.proto.zig");
// enums
pub const TraceProcessorApiVersion = enum(i32) {
    TRACE_PROCESSOR_CURRENT_API_VERSION = 14,
    _PROTOBUF_UNKNOWN = 0,
};
// structs
const TraceProcessorRpcStreamWire = struct {
    const MSG_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const TraceProcessorRpcStream = struct {
    // fields
    msg: ?[]const ?TraceProcessorRpc = null,
    pub fn calcProtobufSize(self: *const TraceProcessorRpcStream) usize {
        var res: usize = 0;
        if (self.msg) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcStreamWire.MSG_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceProcessorRpcStream, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceProcessorRpcStream, target: *gremlin.Writer) void {
        if (self.msg) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceProcessorRpcStreamWire.MSG_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceProcessorRpcStreamWire.MSG_WIRE, 0);
                }
            }
        }
    }
};
pub const TraceProcessorRpcStreamReader = struct {
    buf: gremlin.Reader,
    _msg_offset: ?usize = null,
    _msg_last_offset: ?usize = null,
    _msg_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!TraceProcessorRpcStreamReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceProcessorRpcStreamReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceProcessorRpcStreamWire.MSG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._msg_offset == null) {
                        res._msg_offset = offset - result.size;
                    }
                    res._msg_last_offset = offset;
                    res._msg_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn msgCount(self: *const TraceProcessorRpcStreamReader) usize {
        return self._msg_cnt;
    }
    pub fn msgNext(self: *TraceProcessorRpcStreamReader) ?TraceProcessorRpcReader {
        if (self._msg_offset == null) return null;
        const current_offset = self._msg_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TraceProcessorRpcReader.init(result.value) catch return null;
        if (self._msg_last_offset != null and current_offset >= self._msg_last_offset.?) {
            self._msg_offset = null;
            return msg;
        }
        if (self._msg_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._msg_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceProcessorRpcStreamWire.MSG_WIRE) {
                self._msg_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._msg_offset = null;
        return msg;
    }
};
const TraceProcessorRpcWire = struct {
    const SEQ_WIRE: gremlin.ProtoWireNumber = 1;
    const FATAL_ERROR_WIRE: gremlin.ProtoWireNumber = 5;
    const REQUEST_WIRE: gremlin.ProtoWireNumber = 2;
    const RESPONSE_WIRE: gremlin.ProtoWireNumber = 3;
    const INVALID_REQUEST_WIRE: gremlin.ProtoWireNumber = 4;
    const APPEND_TRACE_DATA_WIRE: gremlin.ProtoWireNumber = 101;
    const QUERY_ARGS_WIRE: gremlin.ProtoWireNumber = 103;
    const COMPUTE_METRIC_ARGS_WIRE: gremlin.ProtoWireNumber = 105;
    const ENABLE_METATRACE_ARGS_WIRE: gremlin.ProtoWireNumber = 106;
    const RESET_TRACE_PROCESSOR_ARGS_WIRE: gremlin.ProtoWireNumber = 107;
    const REGISTER_SQL_PACKAGE_ARGS_WIRE: gremlin.ProtoWireNumber = 108;
    const ANALYZE_STRUCTURED_QUERY_ARGS_WIRE: gremlin.ProtoWireNumber = 109;
    const TRACE_SUMMARY_ARGS_WIRE: gremlin.ProtoWireNumber = 110;
    const APPEND_RESULT_WIRE: gremlin.ProtoWireNumber = 201;
    const QUERY_RESULT_WIRE: gremlin.ProtoWireNumber = 203;
    const METRIC_RESULT_WIRE: gremlin.ProtoWireNumber = 205;
    const METRIC_DESCRIPTORS_WIRE: gremlin.ProtoWireNumber = 206;
    const METATRACE_WIRE: gremlin.ProtoWireNumber = 209;
    const STATUS_WIRE: gremlin.ProtoWireNumber = 210;
    const REGISTER_SQL_PACKAGE_RESULT_WIRE: gremlin.ProtoWireNumber = 211;
    const FINALIZE_DATA_RESULT_WIRE: gremlin.ProtoWireNumber = 212;
    const ANALYZE_STRUCTURED_QUERY_RESULT_WIRE: gremlin.ProtoWireNumber = 213;
    const TRACE_SUMMARY_RESULT_WIRE: gremlin.ProtoWireNumber = 214;
};
pub const TraceProcessorRpc = struct {
    // nested enums
    pub const TraceProcessorMethod = enum(i32) {
        TPM_UNSPECIFIED = 0,
        TPM_APPEND_TRACE_DATA = 1,
        TPM_FINALIZE_TRACE_DATA = 2,
        TPM_QUERY_STREAMING = 3,
        TPM_COMPUTE_METRIC = 5,
        TPM_GET_METRIC_DESCRIPTORS = 6,
        TPM_RESTORE_INITIAL_TABLES = 7,
        TPM_ENABLE_METATRACE = 8,
        TPM_DISABLE_AND_READ_METATRACE = 9,
        TPM_GET_STATUS = 10,
        TPM_RESET_TRACE_PROCESSOR = 11,
        TPM_REGISTER_SQL_PACKAGE = 13,
        TPM_ANALYZE_STRUCTURED_QUERY = 14,
        TPM_SUMMARIZE_TRACE = 15,
    };
    // fields
    seq: i64 = 0,
    fatal_error: ?[]const u8 = null,
    request: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    response: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    invalid_request: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    append_trace_data: ?[]const u8 = null,
    query_args: ?QueryArgs = null,
    compute_metric_args: ?ComputeMetricArgs = null,
    enable_metatrace_args: ?EnableMetatraceArgs = null,
    reset_trace_processor_args: ?ResetTraceProcessorArgs = null,
    register_sql_package_args: ?RegisterSqlPackageArgs = null,
    analyze_structured_query_args: ?AnalyzeStructuredQueryArgs = null,
    trace_summary_args: ?TraceSummaryArgs = null,
    append_result: ?AppendTraceDataResult = null,
    query_result: ?QueryResult = null,
    metric_result: ?ComputeMetricResult = null,
    metric_descriptors: ?DescriptorSet = null,
    metatrace: ?DisableAndReadMetatraceResult = null,
    status: ?StatusResult = null,
    register_sql_package_result: ?RegisterSqlPackageResult = null,
    finalize_data_result: ?FinalizeDataResult = null,
    analyze_structured_query_result: ?AnalyzeStructuredQueryResult = null,
    trace_summary_result: ?TraceSummaryResult = null,
    pub fn calcProtobufSize(self: *const TraceProcessorRpc) usize {
        var res: usize = 0;
        if (self.seq != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.SEQ_WIRE) + gremlin.sizes.sizeI64(self.seq);
        }
        if (self.fatal_error) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.FATAL_ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.request) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.REQUEST_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.request));
        }
        if (@intFromEnum(self.response) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.RESPONSE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.response));
        }
        if (@intFromEnum(self.invalid_request) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.INVALID_REQUEST_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.invalid_request));
        }
        if (self.append_trace_data) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.APPEND_TRACE_DATA_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.query_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.QUERY_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.compute_metric_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.COMPUTE_METRIC_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.enable_metatrace_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.ENABLE_METATRACE_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.reset_trace_processor_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.RESET_TRACE_PROCESSOR_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.register_sql_package_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.analyze_structured_query_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_summary_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.TRACE_SUMMARY_ARGS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.append_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.APPEND_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.query_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.QUERY_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.metric_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.METRIC_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.metric_descriptors) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.METRIC_DESCRIPTORS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.metatrace) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.METATRACE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.STATUS_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.register_sql_package_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.finalize_data_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.FINALIZE_DATA_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.analyze_structured_query_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.trace_summary_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceProcessorRpcWire.TRACE_SUMMARY_RESULT_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceProcessorRpc, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceProcessorRpc, target: *gremlin.Writer) void {
        if (self.seq != 0) {
            target.appendInt64(TraceProcessorRpcWire.SEQ_WIRE, self.seq);
        }
        if (self.fatal_error) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceProcessorRpcWire.FATAL_ERROR_WIRE, v);
            }
        }
        if (@intFromEnum(self.request) != 0) {
            target.appendInt32(TraceProcessorRpcWire.REQUEST_WIRE, @intFromEnum(self.request));
        }
        if (@intFromEnum(self.response) != 0) {
            target.appendInt32(TraceProcessorRpcWire.RESPONSE_WIRE, @intFromEnum(self.response));
        }
        if (@intFromEnum(self.invalid_request) != 0) {
            target.appendInt32(TraceProcessorRpcWire.INVALID_REQUEST_WIRE, @intFromEnum(self.invalid_request));
        }
        if (self.append_trace_data) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceProcessorRpcWire.APPEND_TRACE_DATA_WIRE, v);
            }
        }
        if (self.query_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.QUERY_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.compute_metric_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.COMPUTE_METRIC_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.enable_metatrace_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.ENABLE_METATRACE_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.reset_trace_processor_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.RESET_TRACE_PROCESSOR_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.register_sql_package_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.analyze_structured_query_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_summary_args) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.TRACE_SUMMARY_ARGS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.append_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.APPEND_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.query_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.QUERY_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.metric_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.METRIC_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.metric_descriptors) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.METRIC_DESCRIPTORS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.metatrace) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.METATRACE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.status) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.STATUS_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.register_sql_package_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.finalize_data_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.FINALIZE_DATA_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.analyze_structured_query_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.trace_summary_result) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceProcessorRpcWire.TRACE_SUMMARY_RESULT_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TraceProcessorRpcReader = struct {
    buf: gremlin.Reader,
    _seq: i64 = 0,
    _fatal_error: ?[]const u8 = null,
    _request: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    _response: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    _invalid_request: TraceProcessorRpc.TraceProcessorMethod = @enumFromInt(0),
    _append_trace_data: ?[]const u8 = null,
    _query_args_buf: ?[]const u8 = null,
    _compute_metric_args_buf: ?[]const u8 = null,
    _enable_metatrace_args_buf: ?[]const u8 = null,
    _reset_trace_processor_args_buf: ?[]const u8 = null,
    _register_sql_package_args_buf: ?[]const u8 = null,
    _analyze_structured_query_args_buf: ?[]const u8 = null,
    _trace_summary_args_buf: ?[]const u8 = null,
    _append_result_buf: ?[]const u8 = null,
    _query_result_buf: ?[]const u8 = null,
    _metric_result_buf: ?[]const u8 = null,
    _metric_descriptors_buf: ?[]const u8 = null,
    _metatrace_buf: ?[]const u8 = null,
    _status_buf: ?[]const u8 = null,
    _register_sql_package_result_buf: ?[]const u8 = null,
    _finalize_data_result_buf: ?[]const u8 = null,
    _analyze_structured_query_result_buf: ?[]const u8 = null,
    _trace_summary_result_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TraceProcessorRpcReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceProcessorRpcReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceProcessorRpcWire.SEQ_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._seq = result.value;
                },
                TraceProcessorRpcWire.FATAL_ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._fatal_error = result.value;
                },
                TraceProcessorRpcWire.REQUEST_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._request = @enumFromInt(result.value);
                },
                TraceProcessorRpcWire.RESPONSE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._response = @enumFromInt(result.value);
                },
                TraceProcessorRpcWire.INVALID_REQUEST_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._invalid_request = @enumFromInt(result.value);
                },
                TraceProcessorRpcWire.APPEND_TRACE_DATA_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._append_trace_data = result.value;
                },
                TraceProcessorRpcWire.QUERY_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._query_args_buf = result.value;
                },
                TraceProcessorRpcWire.COMPUTE_METRIC_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._compute_metric_args_buf = result.value;
                },
                TraceProcessorRpcWire.ENABLE_METATRACE_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._enable_metatrace_args_buf = result.value;
                },
                TraceProcessorRpcWire.RESET_TRACE_PROCESSOR_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._reset_trace_processor_args_buf = result.value;
                },
                TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._register_sql_package_args_buf = result.value;
                },
                TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._analyze_structured_query_args_buf = result.value;
                },
                TraceProcessorRpcWire.TRACE_SUMMARY_ARGS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_summary_args_buf = result.value;
                },
                TraceProcessorRpcWire.APPEND_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._append_result_buf = result.value;
                },
                TraceProcessorRpcWire.QUERY_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._query_result_buf = result.value;
                },
                TraceProcessorRpcWire.METRIC_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metric_result_buf = result.value;
                },
                TraceProcessorRpcWire.METRIC_DESCRIPTORS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metric_descriptors_buf = result.value;
                },
                TraceProcessorRpcWire.METATRACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metatrace_buf = result.value;
                },
                TraceProcessorRpcWire.STATUS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._status_buf = result.value;
                },
                TraceProcessorRpcWire.REGISTER_SQL_PACKAGE_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._register_sql_package_result_buf = result.value;
                },
                TraceProcessorRpcWire.FINALIZE_DATA_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._finalize_data_result_buf = result.value;
                },
                TraceProcessorRpcWire.ANALYZE_STRUCTURED_QUERY_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._analyze_structured_query_result_buf = result.value;
                },
                TraceProcessorRpcWire.TRACE_SUMMARY_RESULT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._trace_summary_result_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSeq(self: *const TraceProcessorRpcReader) i64 {
        return self._seq;
    }
    pub inline fn getFatalError(self: *const TraceProcessorRpcReader) []const u8 {
        return self._fatal_error orelse &[_]u8{};
    }
    pub inline fn getRequest(self: *const TraceProcessorRpcReader) TraceProcessorRpc.TraceProcessorMethod {
        return self._request;
    }
    pub inline fn getResponse(self: *const TraceProcessorRpcReader) TraceProcessorRpc.TraceProcessorMethod {
        return self._response;
    }
    pub inline fn getInvalidRequest(self: *const TraceProcessorRpcReader) TraceProcessorRpc.TraceProcessorMethod {
        return self._invalid_request;
    }
    pub inline fn getAppendTraceData(self: *const TraceProcessorRpcReader) []const u8 {
        return self._append_trace_data orelse &[_]u8{};
    }
    pub fn getQueryArgs(self: *const TraceProcessorRpcReader) gremlin.Error!QueryArgsReader {
        if (self._query_args_buf) |buf| {
            return try QueryArgsReader.init(buf);
        }
        return try QueryArgsReader.init(&[_]u8{});
    }
    pub fn getComputeMetricArgs(self: *const TraceProcessorRpcReader) gremlin.Error!ComputeMetricArgsReader {
        if (self._compute_metric_args_buf) |buf| {
            return try ComputeMetricArgsReader.init(buf);
        }
        return try ComputeMetricArgsReader.init(&[_]u8{});
    }
    pub fn getEnableMetatraceArgs(self: *const TraceProcessorRpcReader) gremlin.Error!EnableMetatraceArgsReader {
        if (self._enable_metatrace_args_buf) |buf| {
            return try EnableMetatraceArgsReader.init(buf);
        }
        return try EnableMetatraceArgsReader.init(&[_]u8{});
    }
    pub fn getResetTraceProcessorArgs(self: *const TraceProcessorRpcReader) gremlin.Error!ResetTraceProcessorArgsReader {
        if (self._reset_trace_processor_args_buf) |buf| {
            return try ResetTraceProcessorArgsReader.init(buf);
        }
        return try ResetTraceProcessorArgsReader.init(&[_]u8{});
    }
    pub fn getRegisterSqlPackageArgs(self: *const TraceProcessorRpcReader) gremlin.Error!RegisterSqlPackageArgsReader {
        if (self._register_sql_package_args_buf) |buf| {
            return try RegisterSqlPackageArgsReader.init(buf);
        }
        return try RegisterSqlPackageArgsReader.init(&[_]u8{});
    }
    pub fn getAnalyzeStructuredQueryArgs(self: *const TraceProcessorRpcReader) gremlin.Error!AnalyzeStructuredQueryArgsReader {
        if (self._analyze_structured_query_args_buf) |buf| {
            return try AnalyzeStructuredQueryArgsReader.init(buf);
        }
        return try AnalyzeStructuredQueryArgsReader.init(&[_]u8{});
    }
    pub fn getTraceSummaryArgs(self: *const TraceProcessorRpcReader) gremlin.Error!TraceSummaryArgsReader {
        if (self._trace_summary_args_buf) |buf| {
            return try TraceSummaryArgsReader.init(buf);
        }
        return try TraceSummaryArgsReader.init(&[_]u8{});
    }
    pub fn getAppendResult(self: *const TraceProcessorRpcReader) gremlin.Error!AppendTraceDataResultReader {
        if (self._append_result_buf) |buf| {
            return try AppendTraceDataResultReader.init(buf);
        }
        return try AppendTraceDataResultReader.init(&[_]u8{});
    }
    pub fn getQueryResult(self: *const TraceProcessorRpcReader) gremlin.Error!QueryResultReader {
        if (self._query_result_buf) |buf| {
            return try QueryResultReader.init(buf);
        }
        return try QueryResultReader.init(&[_]u8{});
    }
    pub fn getMetricResult(self: *const TraceProcessorRpcReader) gremlin.Error!ComputeMetricResultReader {
        if (self._metric_result_buf) |buf| {
            return try ComputeMetricResultReader.init(buf);
        }
        return try ComputeMetricResultReader.init(&[_]u8{});
    }
    pub fn getMetricDescriptors(self: *const TraceProcessorRpcReader) gremlin.Error!DescriptorSetReader {
        if (self._metric_descriptors_buf) |buf| {
            return try DescriptorSetReader.init(buf);
        }
        return try DescriptorSetReader.init(&[_]u8{});
    }
    pub fn getMetatrace(self: *const TraceProcessorRpcReader) gremlin.Error!DisableAndReadMetatraceResultReader {
        if (self._metatrace_buf) |buf| {
            return try DisableAndReadMetatraceResultReader.init(buf);
        }
        return try DisableAndReadMetatraceResultReader.init(&[_]u8{});
    }
    pub fn getStatus(self: *const TraceProcessorRpcReader) gremlin.Error!StatusResultReader {
        if (self._status_buf) |buf| {
            return try StatusResultReader.init(buf);
        }
        return try StatusResultReader.init(&[_]u8{});
    }
    pub fn getRegisterSqlPackageResult(self: *const TraceProcessorRpcReader) gremlin.Error!RegisterSqlPackageResultReader {
        if (self._register_sql_package_result_buf) |buf| {
            return try RegisterSqlPackageResultReader.init(buf);
        }
        return try RegisterSqlPackageResultReader.init(&[_]u8{});
    }
    pub fn getFinalizeDataResult(self: *const TraceProcessorRpcReader) gremlin.Error!FinalizeDataResultReader {
        if (self._finalize_data_result_buf) |buf| {
            return try FinalizeDataResultReader.init(buf);
        }
        return try FinalizeDataResultReader.init(&[_]u8{});
    }
    pub fn getAnalyzeStructuredQueryResult(self: *const TraceProcessorRpcReader) gremlin.Error!AnalyzeStructuredQueryResultReader {
        if (self._analyze_structured_query_result_buf) |buf| {
            return try AnalyzeStructuredQueryResultReader.init(buf);
        }
        return try AnalyzeStructuredQueryResultReader.init(&[_]u8{});
    }
    pub fn getTraceSummaryResult(self: *const TraceProcessorRpcReader) gremlin.Error!TraceSummaryResultReader {
        if (self._trace_summary_result_buf) |buf| {
            return try TraceSummaryResultReader.init(buf);
        }
        return try TraceSummaryResultReader.init(&[_]u8{});
    }
};
const AppendTraceDataResultWire = struct {
    const TOTAL_BYTES_PARSED_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AppendTraceDataResult = struct {
    // fields
    total_bytes_parsed: i64 = 0,
    error_: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const AppendTraceDataResult) usize {
        var res: usize = 0;
        if (self.total_bytes_parsed != 0) {
            res += gremlin.sizes.sizeWireNumber(AppendTraceDataResultWire.TOTAL_BYTES_PARSED_WIRE) + gremlin.sizes.sizeI64(self.total_bytes_parsed);
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AppendTraceDataResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const AppendTraceDataResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AppendTraceDataResult, target: *gremlin.Writer) void {
        if (self.total_bytes_parsed != 0) {
            target.appendInt64(AppendTraceDataResultWire.TOTAL_BYTES_PARSED_WIRE, self.total_bytes_parsed);
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(AppendTraceDataResultWire.ERROR_WIRE, v);
            }
        }
    }
};
pub const AppendTraceDataResultReader = struct {
    buf: gremlin.Reader,
    _total_bytes_parsed: i64 = 0,
    _error_: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!AppendTraceDataResultReader {
        const buf = gremlin.Reader.init(src);
        var res = AppendTraceDataResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AppendTraceDataResultWire.TOTAL_BYTES_PARSED_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._total_bytes_parsed = result.value;
                },
                AppendTraceDataResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getTotalBytesParsed(self: *const AppendTraceDataResultReader) i64 {
        return self._total_bytes_parsed;
    }
    pub inline fn getError(self: *const AppendTraceDataResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
};
const QueryArgsWire = struct {
    const SQL_QUERY_WIRE: gremlin.ProtoWireNumber = 1;
    const TAG_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const QueryArgs = struct {
    // fields
    sql_query: ?[]const u8 = null,
    tag: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const QueryArgs) usize {
        var res: usize = 0;
        if (self.sql_query) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryArgsWire.SQL_QUERY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.tag) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryArgsWire.TAG_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const QueryArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const QueryArgs, target: *gremlin.Writer) void {
        if (self.sql_query) |v| {
            if (v.len > 0) {
                target.appendBytes(QueryArgsWire.SQL_QUERY_WIRE, v);
            }
        }
        if (self.tag) |v| {
            if (v.len > 0) {
                target.appendBytes(QueryArgsWire.TAG_WIRE, v);
            }
        }
    }
};
pub const QueryArgsReader = struct {
    buf: gremlin.Reader,
    _sql_query: ?[]const u8 = null,
    _tag: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!QueryArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = QueryArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                QueryArgsWire.SQL_QUERY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sql_query = result.value;
                },
                QueryArgsWire.TAG_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tag = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getSqlQuery(self: *const QueryArgsReader) []const u8 {
        return self._sql_query orelse &[_]u8{};
    }
    pub inline fn getTag(self: *const QueryArgsReader) []const u8 {
        return self._tag orelse &[_]u8{};
    }
};
const QueryResultWire = struct {
    const COLUMN_NAMES_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
    const BATCH_WIRE: gremlin.ProtoWireNumber = 3;
    const STATEMENT_COUNT_WIRE: gremlin.ProtoWireNumber = 4;
    const STATEMENT_WITH_OUTPUT_COUNT_WIRE: gremlin.ProtoWireNumber = 5;
    const LAST_STATEMENT_SQL_WIRE: gremlin.ProtoWireNumber = 6;
};
pub const QueryResult = struct {
    // nested structs
    const CellsBatchWire = struct {
        const CELLS_WIRE: gremlin.ProtoWireNumber = 1;
        const VARINT_CELLS_WIRE: gremlin.ProtoWireNumber = 2;
        const FLOAT64_CELLS_WIRE: gremlin.ProtoWireNumber = 3;
        const BLOB_CELLS_WIRE: gremlin.ProtoWireNumber = 4;
        const STRING_CELLS_WIRE: gremlin.ProtoWireNumber = 5;
        const IS_LAST_BATCH_WIRE: gremlin.ProtoWireNumber = 6;
    };
    pub const CellsBatch = struct {
        // nested enums
        pub const CellType = enum(i32) {
            CELL_INVALID = 0,
            CELL_NULL = 1,
            CELL_VARINT = 2,
            CELL_FLOAT64 = 3,
            CELL_STRING = 4,
            CELL_BLOB = 5,
        };
        // fields
        cells: ?[]const QueryResult.CellsBatch.CellType = null,
        varint_cells: ?[]const i64 = null,
        float64_cells: ?[]const f64 = null,
        blob_cells: ?[]const ?[]const u8 = null,
        string_cells: ?[]const u8 = null,
        is_last_batch: bool = false,
        pub fn calcProtobufSize(self: *const QueryResult.CellsBatch) usize {
            var res: usize = 0;
            if (self.cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.CELLS_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.CELLS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.varint_cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.VARINT_CELLS_WIRE) + gremlin.sizes.sizeI64(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.VARINT_CELLS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.float64_cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeDouble(v);
                    }
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
                }
            }
            if (self.blob_cells) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.BLOB_CELLS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.string_cells) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.STRING_CELLS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.is_last_batch != false) {
                res += gremlin.sizes.sizeWireNumber(QueryResult.CellsBatchWire.IS_LAST_BATCH_WIRE) + gremlin.sizes.sizeBool(self.is_last_batch);
            }
            return res;
        }
        pub fn encode(self: *const QueryResult.CellsBatch, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const QueryResult.CellsBatch, target: *gremlin.Writer) void {
            if (self.cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt32(QueryResult.CellsBatchWire.CELLS_WIRE, @intFromEnum(arr[0]));
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                    }
                    target.appendBytesTag(QueryResult.CellsBatchWire.CELLS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt32WithoutTag(@intFromEnum(v));
                    }
                }
            }
            if (self.varint_cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendInt64(QueryResult.CellsBatchWire.VARINT_CELLS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeI64(v);
                    }
                    target.appendBytesTag(QueryResult.CellsBatchWire.VARINT_CELLS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendInt64WithoutTag(v);
                    }
                }
            }
            if (self.float64_cells) |arr| {
                if (arr.len == 0) {} else if (arr.len == 1) {
                    target.appendFloat64(QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE, arr[0]);
                } else {
                    var packed_size: usize = 0;
                    for (arr) |v| {
                        packed_size += gremlin.sizes.sizeDouble(v);
                    }
                    target.appendBytesTag(QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE, packed_size);
                    for (arr) |v| {
                        target.appendFloat64WithoutTag(v);
                    }
                }
            }
            if (self.blob_cells) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(QueryResult.CellsBatchWire.BLOB_CELLS_WIRE, v);
                    } else {
                        target.appendBytesTag(QueryResult.CellsBatchWire.BLOB_CELLS_WIRE, 0);
                    }
                }
            }
            if (self.string_cells) |v| {
                if (v.len > 0) {
                    target.appendBytes(QueryResult.CellsBatchWire.STRING_CELLS_WIRE, v);
                }
            }
            if (self.is_last_batch != false) {
                target.appendBool(QueryResult.CellsBatchWire.IS_LAST_BATCH_WIRE, self.is_last_batch);
            }
        }
    };
    pub const CellsBatchReader = struct {
        buf: gremlin.Reader,
        _cells_offset: ?usize = null,
        _cells_last_offset: ?usize = null,
        _cells_packed: bool = false,
        _varint_cells_offset: ?usize = null,
        _varint_cells_last_offset: ?usize = null,
        _varint_cells_packed: bool = false,
        _float64_cells_offset: ?usize = null,
        _float64_cells_last_offset: ?usize = null,
        _float64_cells_packed: bool = false,
        _blob_cells_offset: ?usize = null,
        _blob_cells_last_offset: ?usize = null,
        _blob_cells_cnt: usize = 0,
        _string_cells: ?[]const u8 = null,
        _is_last_batch: bool = false,
        pub fn init(src: []const u8) gremlin.Error!QueryResult.CellsBatchReader {
            const buf = gremlin.Reader.init(src);
            var res = QueryResult.CellsBatchReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    QueryResult.CellsBatchWire.CELLS_WIRE => {
                        if (res._cells_offset == null) {
                            res._cells_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._cells_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._cells_offset = offset + length_result.size;
                            res._cells_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._cells_last_offset.?;
                        } else {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._cells_last_offset = offset;
                        }
                    },
                    QueryResult.CellsBatchWire.VARINT_CELLS_WIRE => {
                        if (res._varint_cells_offset == null) {
                            res._varint_cells_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._varint_cells_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._varint_cells_offset = offset + length_result.size;
                            res._varint_cells_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._varint_cells_last_offset.?;
                        } else {
                            const result = try buf.readInt64(offset);
                            offset += result.size;
                            res._varint_cells_last_offset = offset;
                        }
                    },
                    QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE => {
                        if (res._float64_cells_offset == null) {
                            res._float64_cells_offset = offset;
                        }
                        if (tag.wire == gremlin.ProtoWireType.bytes) {
                            res._float64_cells_packed = true;
                            const length_result = try buf.readVarInt(offset);
                            res._float64_cells_offset = offset + length_result.size;
                            res._float64_cells_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                            offset = res._float64_cells_last_offset.?;
                        } else {
                            const result = try buf.readFloat64(offset);
                            offset += result.size;
                            res._float64_cells_last_offset = offset;
                        }
                    },
                    QueryResult.CellsBatchWire.BLOB_CELLS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._blob_cells_offset == null) {
                            res._blob_cells_offset = offset - result.size;
                        }
                        res._blob_cells_last_offset = offset;
                        res._blob_cells_cnt += 1;
                    },
                    QueryResult.CellsBatchWire.STRING_CELLS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._string_cells = result.value;
                    },
                    QueryResult.CellsBatchWire.IS_LAST_BATCH_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._is_last_batch = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn cellsNext(self: *QueryResult.CellsBatchReader) gremlin.Error!?QueryResult.CellsBatch.CellType {
            if (self._cells_offset == null) return null;
            const current_offset = self._cells_offset.?;
            if (current_offset >= self._cells_last_offset.?) {
                self._cells_offset = null;
                return null;
            }
            if (self._cells_packed) {
                const value_result = try self.buf.readInt32(current_offset);
                self._cells_offset = current_offset + value_result.size;
                if (self._cells_offset.? >= self._cells_last_offset.?) {
                    self._cells_offset = null;
                }
                return @enumFromInt(value_result.value);
            } else {
                const value_result = try self.buf.readInt32(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._cells_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == QueryResult.CellsBatchWire.CELLS_WIRE) {
                        self._cells_offset = next_offset;
                        return @enumFromInt(value_result.value);
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._cells_offset = null;
                return @enumFromInt(value_result.value);
            }
        }
        pub fn varintCellsNext(self: *QueryResult.CellsBatchReader) gremlin.Error!?i64 {
            if (self._varint_cells_offset == null) return null;
            const current_offset = self._varint_cells_offset.?;
            if (current_offset >= self._varint_cells_last_offset.?) {
                self._varint_cells_offset = null;
                return null;
            }
            if (self._varint_cells_packed) {
                const value_result = try self.buf.readInt64(current_offset);
                self._varint_cells_offset = current_offset + value_result.size;
                if (self._varint_cells_offset.? >= self._varint_cells_last_offset.?) {
                    self._varint_cells_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readInt64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._varint_cells_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == QueryResult.CellsBatchWire.VARINT_CELLS_WIRE) {
                        self._varint_cells_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._varint_cells_offset = null;
                return value_result.value;
            }
        }
        pub fn float64CellsNext(self: *QueryResult.CellsBatchReader) gremlin.Error!?f64 {
            if (self._float64_cells_offset == null) return null;
            const current_offset = self._float64_cells_offset.?;
            if (current_offset >= self._float64_cells_last_offset.?) {
                self._float64_cells_offset = null;
                return null;
            }
            if (self._float64_cells_packed) {
                const value_result = try self.buf.readFloat64(current_offset);
                self._float64_cells_offset = current_offset + value_result.size;
                if (self._float64_cells_offset.? >= self._float64_cells_last_offset.?) {
                    self._float64_cells_offset = null;
                }
                return value_result.value;
            } else {
                const value_result = try self.buf.readFloat64(current_offset);
                var next_offset = current_offset + value_result.size;
                const max_offset = self._float64_cells_last_offset.?;
                // Search for the next occurrence of this field
                while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                    const next_tag = try self.buf.readTagAt(next_offset);
                    next_offset += next_tag.size;
                    if (next_tag.number == QueryResult.CellsBatchWire.FLOAT64_CELLS_WIRE) {
                        self._float64_cells_offset = next_offset;
                        return value_result.value;
                    } else {
                        next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                    }
                }
                self._float64_cells_offset = null;
                return value_result.value;
            }
        }
        pub fn blobCellsCount(self: *const QueryResult.CellsBatchReader) usize {
            return self._blob_cells_cnt;
        }
        pub fn blobCellsNext(self: *QueryResult.CellsBatchReader) ?[]const u8 {
            if (self._blob_cells_offset == null) return null;
            const current_offset = self._blob_cells_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._blob_cells_last_offset != null and current_offset >= self._blob_cells_last_offset.?) {
                self._blob_cells_offset = null;
                return result.value;
            }
            if (self._blob_cells_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._blob_cells_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == QueryResult.CellsBatchWire.BLOB_CELLS_WIRE) {
                    self._blob_cells_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._blob_cells_offset = null;
            return result.value;
        }
        pub inline fn getStringCells(self: *const QueryResult.CellsBatchReader) []const u8 {
            return self._string_cells orelse &[_]u8{};
        }
        pub inline fn getIsLastBatch(self: *const QueryResult.CellsBatchReader) bool {
            return self._is_last_batch;
        }
    };
    // fields
    column_names: ?[]const ?[]const u8 = null,
    error_: ?[]const u8 = null,
    batch: ?[]const ?QueryResult.CellsBatch = null,
    statement_count: u32 = 0,
    statement_with_output_count: u32 = 0,
    last_statement_sql: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const QueryResult) usize {
        var res: usize = 0;
        if (self.column_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(QueryResultWire.COLUMN_NAMES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.batch) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(QueryResultWire.BATCH_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.statement_count != 0) {
            res += gremlin.sizes.sizeWireNumber(QueryResultWire.STATEMENT_COUNT_WIRE) + gremlin.sizes.sizeU32(self.statement_count);
        }
        if (self.statement_with_output_count != 0) {
            res += gremlin.sizes.sizeWireNumber(QueryResultWire.STATEMENT_WITH_OUTPUT_COUNT_WIRE) + gremlin.sizes.sizeU32(self.statement_with_output_count);
        }
        if (self.last_statement_sql) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(QueryResultWire.LAST_STATEMENT_SQL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const QueryResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const QueryResult, target: *gremlin.Writer) void {
        if (self.column_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(QueryResultWire.COLUMN_NAMES_WIRE, v);
                } else {
                    target.appendBytesTag(QueryResultWire.COLUMN_NAMES_WIRE, 0);
                }
            }
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(QueryResultWire.ERROR_WIRE, v);
            }
        }
        if (self.batch) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(QueryResultWire.BATCH_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(QueryResultWire.BATCH_WIRE, 0);
                }
            }
        }
        if (self.statement_count != 0) {
            target.appendUint32(QueryResultWire.STATEMENT_COUNT_WIRE, self.statement_count);
        }
        if (self.statement_with_output_count != 0) {
            target.appendUint32(QueryResultWire.STATEMENT_WITH_OUTPUT_COUNT_WIRE, self.statement_with_output_count);
        }
        if (self.last_statement_sql) |v| {
            if (v.len > 0) {
                target.appendBytes(QueryResultWire.LAST_STATEMENT_SQL_WIRE, v);
            }
        }
    }
};
pub const QueryResultReader = struct {
    buf: gremlin.Reader,
    _column_names_offset: ?usize = null,
    _column_names_last_offset: ?usize = null,
    _column_names_cnt: usize = 0,
    _error_: ?[]const u8 = null,
    _batch_offset: ?usize = null,
    _batch_last_offset: ?usize = null,
    _batch_cnt: usize = 0,
    _statement_count: u32 = 0,
    _statement_with_output_count: u32 = 0,
    _last_statement_sql: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!QueryResultReader {
        const buf = gremlin.Reader.init(src);
        var res = QueryResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                QueryResultWire.COLUMN_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._column_names_offset == null) {
                        res._column_names_offset = offset - result.size;
                    }
                    res._column_names_last_offset = offset;
                    res._column_names_cnt += 1;
                },
                QueryResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                QueryResultWire.BATCH_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._batch_offset == null) {
                        res._batch_offset = offset - result.size;
                    }
                    res._batch_last_offset = offset;
                    res._batch_cnt += 1;
                },
                QueryResultWire.STATEMENT_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._statement_count = result.value;
                },
                QueryResultWire.STATEMENT_WITH_OUTPUT_COUNT_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._statement_with_output_count = result.value;
                },
                QueryResultWire.LAST_STATEMENT_SQL_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._last_statement_sql = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn columnNamesCount(self: *const QueryResultReader) usize {
        return self._column_names_cnt;
    }
    pub fn columnNamesNext(self: *QueryResultReader) ?[]const u8 {
        if (self._column_names_offset == null) return null;
        const current_offset = self._column_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._column_names_last_offset != null and current_offset >= self._column_names_last_offset.?) {
            self._column_names_offset = null;
            return result.value;
        }
        if (self._column_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._column_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == QueryResultWire.COLUMN_NAMES_WIRE) {
                self._column_names_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._column_names_offset = null;
        return result.value;
    }
    pub inline fn getError(self: *const QueryResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub fn batchCount(self: *const QueryResultReader) usize {
        return self._batch_cnt;
    }
    pub fn batchNext(self: *QueryResultReader) ?QueryResult.CellsBatchReader {
        if (self._batch_offset == null) return null;
        const current_offset = self._batch_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = QueryResult.CellsBatchReader.init(result.value) catch return null;
        if (self._batch_last_offset != null and current_offset >= self._batch_last_offset.?) {
            self._batch_offset = null;
            return msg;
        }
        if (self._batch_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._batch_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == QueryResultWire.BATCH_WIRE) {
                self._batch_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._batch_offset = null;
        return msg;
    }
    pub inline fn getStatementCount(self: *const QueryResultReader) u32 {
        return self._statement_count;
    }
    pub inline fn getStatementWithOutputCount(self: *const QueryResultReader) u32 {
        return self._statement_with_output_count;
    }
    pub inline fn getLastStatementSql(self: *const QueryResultReader) []const u8 {
        return self._last_statement_sql orelse &[_]u8{};
    }
};
pub const StatusArgs = struct {
    pub fn calcProtobufSize(_: *const StatusArgs) usize {
        return 0;
    }
    pub fn encode(self: *const StatusArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const StatusArgs, _: *gremlin.Writer) void {}
};
pub const StatusArgsReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!StatusArgsReader {
        const buf = gremlin.Reader.init(src);
        return StatusArgsReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const StatusResultWire = struct {
    const LOADED_TRACE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const HUMAN_READABLE_VERSION_WIRE: gremlin.ProtoWireNumber = 2;
    const API_VERSION_WIRE: gremlin.ProtoWireNumber = 3;
    const VERSION_CODE_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const StatusResult = struct {
    // fields
    loaded_trace_name: ?[]const u8 = null,
    human_readable_version: ?[]const u8 = null,
    api_version: i32 = 0,
    version_code: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const StatusResult) usize {
        var res: usize = 0;
        if (self.loaded_trace_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(StatusResultWire.LOADED_TRACE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.human_readable_version) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(StatusResultWire.HUMAN_READABLE_VERSION_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.api_version != 0) {
            res += gremlin.sizes.sizeWireNumber(StatusResultWire.API_VERSION_WIRE) + gremlin.sizes.sizeI32(self.api_version);
        }
        if (self.version_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(StatusResultWire.VERSION_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const StatusResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const StatusResult, target: *gremlin.Writer) void {
        if (self.loaded_trace_name) |v| {
            if (v.len > 0) {
                target.appendBytes(StatusResultWire.LOADED_TRACE_NAME_WIRE, v);
            }
        }
        if (self.human_readable_version) |v| {
            if (v.len > 0) {
                target.appendBytes(StatusResultWire.HUMAN_READABLE_VERSION_WIRE, v);
            }
        }
        if (self.api_version != 0) {
            target.appendInt32(StatusResultWire.API_VERSION_WIRE, self.api_version);
        }
        if (self.version_code) |v| {
            if (v.len > 0) {
                target.appendBytes(StatusResultWire.VERSION_CODE_WIRE, v);
            }
        }
    }
};
pub const StatusResultReader = struct {
    buf: gremlin.Reader,
    _loaded_trace_name: ?[]const u8 = null,
    _human_readable_version: ?[]const u8 = null,
    _api_version: i32 = 0,
    _version_code: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!StatusResultReader {
        const buf = gremlin.Reader.init(src);
        var res = StatusResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                StatusResultWire.LOADED_TRACE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._loaded_trace_name = result.value;
                },
                StatusResultWire.HUMAN_READABLE_VERSION_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._human_readable_version = result.value;
                },
                StatusResultWire.API_VERSION_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._api_version = result.value;
                },
                StatusResultWire.VERSION_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._version_code = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getLoadedTraceName(self: *const StatusResultReader) []const u8 {
        return self._loaded_trace_name orelse &[_]u8{};
    }
    pub inline fn getHumanReadableVersion(self: *const StatusResultReader) []const u8 {
        return self._human_readable_version orelse &[_]u8{};
    }
    pub inline fn getApiVersion(self: *const StatusResultReader) i32 {
        return self._api_version;
    }
    pub inline fn getVersionCode(self: *const StatusResultReader) []const u8 {
        return self._version_code orelse &[_]u8{};
    }
};
const ComputeMetricArgsWire = struct {
    const METRIC_NAMES_WIRE: gremlin.ProtoWireNumber = 1;
    const FORMAT_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const ComputeMetricArgs = struct {
    // nested enums
    pub const ResultFormat = enum(i32) {
        BINARY_PROTOBUF = 0,
        TEXTPROTO = 1,
        JSON = 2,
    };
    // fields
    metric_names: ?[]const ?[]const u8 = null,
    format: ComputeMetricArgs.ResultFormat = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const ComputeMetricArgs) usize {
        var res: usize = 0;
        if (self.metric_names) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ComputeMetricArgsWire.METRIC_NAMES_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.format) != 0) {
            res += gremlin.sizes.sizeWireNumber(ComputeMetricArgsWire.FORMAT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.format));
        }
        return res;
    }
    pub fn encode(self: *const ComputeMetricArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ComputeMetricArgs, target: *gremlin.Writer) void {
        if (self.metric_names) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ComputeMetricArgsWire.METRIC_NAMES_WIRE, v);
                } else {
                    target.appendBytesTag(ComputeMetricArgsWire.METRIC_NAMES_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.format) != 0) {
            target.appendInt32(ComputeMetricArgsWire.FORMAT_WIRE, @intFromEnum(self.format));
        }
    }
};
pub const ComputeMetricArgsReader = struct {
    buf: gremlin.Reader,
    _metric_names_offset: ?usize = null,
    _metric_names_last_offset: ?usize = null,
    _metric_names_cnt: usize = 0,
    _format: ComputeMetricArgs.ResultFormat = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!ComputeMetricArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = ComputeMetricArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ComputeMetricArgsWire.METRIC_NAMES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._metric_names_offset == null) {
                        res._metric_names_offset = offset - result.size;
                    }
                    res._metric_names_last_offset = offset;
                    res._metric_names_cnt += 1;
                },
                ComputeMetricArgsWire.FORMAT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._format = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn metricNamesCount(self: *const ComputeMetricArgsReader) usize {
        return self._metric_names_cnt;
    }
    pub fn metricNamesNext(self: *ComputeMetricArgsReader) ?[]const u8 {
        if (self._metric_names_offset == null) return null;
        const current_offset = self._metric_names_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._metric_names_last_offset != null and current_offset >= self._metric_names_last_offset.?) {
            self._metric_names_offset = null;
            return result.value;
        }
        if (self._metric_names_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._metric_names_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ComputeMetricArgsWire.METRIC_NAMES_WIRE) {
                self._metric_names_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._metric_names_offset = null;
        return result.value;
    }
    pub inline fn getFormat(self: *const ComputeMetricArgsReader) ComputeMetricArgs.ResultFormat {
        return self._format;
    }
};
const ComputeMetricResultWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
    const METRICS_WIRE: gremlin.ProtoWireNumber = 1;
    const METRICS_AS_PROTOTEXT_WIRE: gremlin.ProtoWireNumber = 3;
    const METRICS_AS_JSON_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const ComputeMetricResult = struct {
    // fields
    error_: ?[]const u8 = null,
    metrics: ?[]const u8 = null,
    metrics_as_prototext: ?[]const u8 = null,
    metrics_as_json: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ComputeMetricResult) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ComputeMetricResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.metrics) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ComputeMetricResultWire.METRICS_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.metrics_as_prototext) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ComputeMetricResultWire.METRICS_AS_PROTOTEXT_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.metrics_as_json) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(ComputeMetricResultWire.METRICS_AS_JSON_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const ComputeMetricResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ComputeMetricResult, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(ComputeMetricResultWire.ERROR_WIRE, v);
            }
        }
        if (self.metrics) |v| {
            if (v.len > 0) {
                target.appendBytes(ComputeMetricResultWire.METRICS_WIRE, v);
            }
        }
        if (self.metrics_as_prototext) |v| {
            if (v.len > 0) {
                target.appendBytes(ComputeMetricResultWire.METRICS_AS_PROTOTEXT_WIRE, v);
            }
        }
        if (self.metrics_as_json) |v| {
            if (v.len > 0) {
                target.appendBytes(ComputeMetricResultWire.METRICS_AS_JSON_WIRE, v);
            }
        }
    }
};
pub const ComputeMetricResultReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    _metrics: ?[]const u8 = null,
    _metrics_as_prototext: ?[]const u8 = null,
    _metrics_as_json: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!ComputeMetricResultReader {
        const buf = gremlin.Reader.init(src);
        var res = ComputeMetricResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ComputeMetricResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                ComputeMetricResultWire.METRICS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metrics = result.value;
                },
                ComputeMetricResultWire.METRICS_AS_PROTOTEXT_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metrics_as_prototext = result.value;
                },
                ComputeMetricResultWire.METRICS_AS_JSON_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metrics_as_json = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const ComputeMetricResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub inline fn getMetrics(self: *const ComputeMetricResultReader) []const u8 {
        return self._metrics orelse &[_]u8{};
    }
    pub inline fn getMetricsAsPrototext(self: *const ComputeMetricResultReader) []const u8 {
        return self._metrics_as_prototext orelse &[_]u8{};
    }
    pub inline fn getMetricsAsJson(self: *const ComputeMetricResultReader) []const u8 {
        return self._metrics_as_json orelse &[_]u8{};
    }
};
const EnableMetatraceArgsWire = struct {
    const CATEGORIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const EnableMetatraceArgs = struct {
    // fields
    categories: metatrace_categories.MetatraceCategories = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const EnableMetatraceArgs) usize {
        var res: usize = 0;
        if (@intFromEnum(self.categories) != 0) {
            res += gremlin.sizes.sizeWireNumber(EnableMetatraceArgsWire.CATEGORIES_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.categories));
        }
        return res;
    }
    pub fn encode(self: *const EnableMetatraceArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EnableMetatraceArgs, target: *gremlin.Writer) void {
        if (@intFromEnum(self.categories) != 0) {
            target.appendInt32(EnableMetatraceArgsWire.CATEGORIES_WIRE, @intFromEnum(self.categories));
        }
    }
};
pub const EnableMetatraceArgsReader = struct {
    buf: gremlin.Reader,
    _categories: metatrace_categories.MetatraceCategories = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!EnableMetatraceArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = EnableMetatraceArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EnableMetatraceArgsWire.CATEGORIES_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._categories = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getCategories(self: *const EnableMetatraceArgsReader) metatrace_categories.MetatraceCategories {
        return self._categories;
    }
};
pub const EnableMetatraceResult = struct {
    pub fn calcProtobufSize(_: *const EnableMetatraceResult) usize {
        return 0;
    }
    pub fn encode(self: *const EnableMetatraceResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const EnableMetatraceResult, _: *gremlin.Writer) void {}
};
pub const EnableMetatraceResultReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!EnableMetatraceResultReader {
        const buf = gremlin.Reader.init(src);
        return EnableMetatraceResultReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
pub const DisableAndReadMetatraceArgs = struct {
    pub fn calcProtobufSize(_: *const DisableAndReadMetatraceArgs) usize {
        return 0;
    }
    pub fn encode(self: *const DisableAndReadMetatraceArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(_: *const DisableAndReadMetatraceArgs, _: *gremlin.Writer) void {}
};
pub const DisableAndReadMetatraceArgsReader = struct {
    buf: gremlin.Reader,
    pub fn init(src: []const u8) gremlin.Error!DisableAndReadMetatraceArgsReader {
        const buf = gremlin.Reader.init(src);
        return DisableAndReadMetatraceArgsReader{ .buf = buf };
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
};
const DisableAndReadMetatraceResultWire = struct {
    const METATRACE_WIRE: gremlin.ProtoWireNumber = 1;
    const ERROR_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const DisableAndReadMetatraceResult = struct {
    // fields
    metatrace: ?[]const u8 = null,
    error_: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const DisableAndReadMetatraceResult) usize {
        var res: usize = 0;
        if (self.metatrace) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DisableAndReadMetatraceResultWire.METATRACE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(DisableAndReadMetatraceResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const DisableAndReadMetatraceResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DisableAndReadMetatraceResult, target: *gremlin.Writer) void {
        if (self.metatrace) |v| {
            if (v.len > 0) {
                target.appendBytes(DisableAndReadMetatraceResultWire.METATRACE_WIRE, v);
            }
        }
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(DisableAndReadMetatraceResultWire.ERROR_WIRE, v);
            }
        }
    }
};
pub const DisableAndReadMetatraceResultReader = struct {
    buf: gremlin.Reader,
    _metatrace: ?[]const u8 = null,
    _error_: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!DisableAndReadMetatraceResultReader {
        const buf = gremlin.Reader.init(src);
        var res = DisableAndReadMetatraceResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DisableAndReadMetatraceResultWire.METATRACE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._metatrace = result.value;
                },
                DisableAndReadMetatraceResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getMetatrace(self: *const DisableAndReadMetatraceResultReader) []const u8 {
        return self._metatrace orelse &[_]u8{};
    }
    pub inline fn getError(self: *const DisableAndReadMetatraceResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
};
const DescriptorSetWire = struct {
    const DESCRIPTORS_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const DescriptorSet = struct {
    // fields
    descriptors: ?[]const ?descriptor.DescriptorProto = null,
    pub fn calcProtobufSize(self: *const DescriptorSet) usize {
        var res: usize = 0;
        if (self.descriptors) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(DescriptorSetWire.DESCRIPTORS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const DescriptorSet, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DescriptorSet, target: *gremlin.Writer) void {
        if (self.descriptors) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(DescriptorSetWire.DESCRIPTORS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(DescriptorSetWire.DESCRIPTORS_WIRE, 0);
                }
            }
        }
    }
};
pub const DescriptorSetReader = struct {
    buf: gremlin.Reader,
    _descriptors_offset: ?usize = null,
    _descriptors_last_offset: ?usize = null,
    _descriptors_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!DescriptorSetReader {
        const buf = gremlin.Reader.init(src);
        var res = DescriptorSetReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DescriptorSetWire.DESCRIPTORS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._descriptors_offset == null) {
                        res._descriptors_offset = offset - result.size;
                    }
                    res._descriptors_last_offset = offset;
                    res._descriptors_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn descriptorsCount(self: *const DescriptorSetReader) usize {
        return self._descriptors_cnt;
    }
    pub fn descriptorsNext(self: *DescriptorSetReader) ?descriptor.DescriptorProtoReader {
        if (self._descriptors_offset == null) return null;
        const current_offset = self._descriptors_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = descriptor.DescriptorProtoReader.init(result.value) catch return null;
        if (self._descriptors_last_offset != null and current_offset >= self._descriptors_last_offset.?) {
            self._descriptors_offset = null;
            return msg;
        }
        if (self._descriptors_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._descriptors_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == DescriptorSetWire.DESCRIPTORS_WIRE) {
                self._descriptors_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._descriptors_offset = null;
        return msg;
    }
};
const ResetTraceProcessorArgsWire = struct {
    const DROP_TRACK_EVENT_DATA_BEFORE_WIRE: gremlin.ProtoWireNumber = 1;
    const INGEST_FTRACE_IN_RAW_TABLE_WIRE: gremlin.ProtoWireNumber = 2;
    const ANALYZE_TRACE_PROTO_CONTENT_WIRE: gremlin.ProtoWireNumber = 3;
    const FTRACE_DROP_UNTIL_ALL_CPUS_VALID_WIRE: gremlin.ProtoWireNumber = 4;
    const PARSING_MODE_WIRE: gremlin.ProtoWireNumber = 5;
    const SORTING_MODE_WIRE: gremlin.ProtoWireNumber = 6;
    const EXTRA_PARSING_DESCRIPTORS_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const ResetTraceProcessorArgs = struct {
    // nested enums
    pub const DropTrackEventDataBefore = enum(i32) {
        NO_DROP = 0,
        TRACK_EVENT_RANGE_OF_INTEREST = 1,
    };
    pub const ParsingMode = enum(i32) {
        DEFAULT = 0,
        TOKENIZE_ONLY = 1,
        TOKENIZE_AND_SORT = 2,
    };
    pub const SortingMode = enum(i32) {
        DEFAULT_HEURISTICS = 0,
        FORCE_FULL_SORT = 1,
    };
    // fields
    drop_track_event_data_before: ResetTraceProcessorArgs.DropTrackEventDataBefore = @enumFromInt(0),
    ingest_ftrace_in_raw_table: bool = false,
    analyze_trace_proto_content: bool = false,
    ftrace_drop_until_all_cpus_valid: bool = false,
    parsing_mode: ResetTraceProcessorArgs.ParsingMode = @enumFromInt(0),
    sorting_mode: ResetTraceProcessorArgs.SortingMode = @enumFromInt(0),
    extra_parsing_descriptors: ?[]const ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const ResetTraceProcessorArgs) usize {
        var res: usize = 0;
        if (@intFromEnum(self.drop_track_event_data_before) != 0) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.DROP_TRACK_EVENT_DATA_BEFORE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.drop_track_event_data_before));
        }
        if (self.ingest_ftrace_in_raw_table != false) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.INGEST_FTRACE_IN_RAW_TABLE_WIRE) + gremlin.sizes.sizeBool(self.ingest_ftrace_in_raw_table);
        }
        if (self.analyze_trace_proto_content != false) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.ANALYZE_TRACE_PROTO_CONTENT_WIRE) + gremlin.sizes.sizeBool(self.analyze_trace_proto_content);
        }
        if (self.ftrace_drop_until_all_cpus_valid != false) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.FTRACE_DROP_UNTIL_ALL_CPUS_VALID_WIRE) + gremlin.sizes.sizeBool(self.ftrace_drop_until_all_cpus_valid);
        }
        if (@intFromEnum(self.parsing_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.PARSING_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.parsing_mode));
        }
        if (@intFromEnum(self.sorting_mode) != 0) {
            res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.SORTING_MODE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.sorting_mode));
        }
        if (self.extra_parsing_descriptors) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(ResetTraceProcessorArgsWire.EXTRA_PARSING_DESCRIPTORS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const ResetTraceProcessorArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const ResetTraceProcessorArgs, target: *gremlin.Writer) void {
        if (@intFromEnum(self.drop_track_event_data_before) != 0) {
            target.appendInt32(ResetTraceProcessorArgsWire.DROP_TRACK_EVENT_DATA_BEFORE_WIRE, @intFromEnum(self.drop_track_event_data_before));
        }
        if (self.ingest_ftrace_in_raw_table != false) {
            target.appendBool(ResetTraceProcessorArgsWire.INGEST_FTRACE_IN_RAW_TABLE_WIRE, self.ingest_ftrace_in_raw_table);
        }
        if (self.analyze_trace_proto_content != false) {
            target.appendBool(ResetTraceProcessorArgsWire.ANALYZE_TRACE_PROTO_CONTENT_WIRE, self.analyze_trace_proto_content);
        }
        if (self.ftrace_drop_until_all_cpus_valid != false) {
            target.appendBool(ResetTraceProcessorArgsWire.FTRACE_DROP_UNTIL_ALL_CPUS_VALID_WIRE, self.ftrace_drop_until_all_cpus_valid);
        }
        if (@intFromEnum(self.parsing_mode) != 0) {
            target.appendInt32(ResetTraceProcessorArgsWire.PARSING_MODE_WIRE, @intFromEnum(self.parsing_mode));
        }
        if (@intFromEnum(self.sorting_mode) != 0) {
            target.appendInt32(ResetTraceProcessorArgsWire.SORTING_MODE_WIRE, @intFromEnum(self.sorting_mode));
        }
        if (self.extra_parsing_descriptors) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(ResetTraceProcessorArgsWire.EXTRA_PARSING_DESCRIPTORS_WIRE, v);
                } else {
                    target.appendBytesTag(ResetTraceProcessorArgsWire.EXTRA_PARSING_DESCRIPTORS_WIRE, 0);
                }
            }
        }
    }
};
pub const ResetTraceProcessorArgsReader = struct {
    buf: gremlin.Reader,
    _drop_track_event_data_before: ResetTraceProcessorArgs.DropTrackEventDataBefore = @enumFromInt(0),
    _ingest_ftrace_in_raw_table: bool = false,
    _analyze_trace_proto_content: bool = false,
    _ftrace_drop_until_all_cpus_valid: bool = false,
    _parsing_mode: ResetTraceProcessorArgs.ParsingMode = @enumFromInt(0),
    _sorting_mode: ResetTraceProcessorArgs.SortingMode = @enumFromInt(0),
    _extra_parsing_descriptors_offset: ?usize = null,
    _extra_parsing_descriptors_last_offset: ?usize = null,
    _extra_parsing_descriptors_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!ResetTraceProcessorArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = ResetTraceProcessorArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                ResetTraceProcessorArgsWire.DROP_TRACK_EVENT_DATA_BEFORE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._drop_track_event_data_before = @enumFromInt(result.value);
                },
                ResetTraceProcessorArgsWire.INGEST_FTRACE_IN_RAW_TABLE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._ingest_ftrace_in_raw_table = result.value;
                },
                ResetTraceProcessorArgsWire.ANALYZE_TRACE_PROTO_CONTENT_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._analyze_trace_proto_content = result.value;
                },
                ResetTraceProcessorArgsWire.FTRACE_DROP_UNTIL_ALL_CPUS_VALID_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._ftrace_drop_until_all_cpus_valid = result.value;
                },
                ResetTraceProcessorArgsWire.PARSING_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._parsing_mode = @enumFromInt(result.value);
                },
                ResetTraceProcessorArgsWire.SORTING_MODE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._sorting_mode = @enumFromInt(result.value);
                },
                ResetTraceProcessorArgsWire.EXTRA_PARSING_DESCRIPTORS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._extra_parsing_descriptors_offset == null) {
                        res._extra_parsing_descriptors_offset = offset - result.size;
                    }
                    res._extra_parsing_descriptors_last_offset = offset;
                    res._extra_parsing_descriptors_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getDropTrackEventDataBefore(self: *const ResetTraceProcessorArgsReader) ResetTraceProcessorArgs.DropTrackEventDataBefore {
        return self._drop_track_event_data_before;
    }
    pub inline fn getIngestFtraceInRawTable(self: *const ResetTraceProcessorArgsReader) bool {
        return self._ingest_ftrace_in_raw_table;
    }
    pub inline fn getAnalyzeTraceProtoContent(self: *const ResetTraceProcessorArgsReader) bool {
        return self._analyze_trace_proto_content;
    }
    pub inline fn getFtraceDropUntilAllCpusValid(self: *const ResetTraceProcessorArgsReader) bool {
        return self._ftrace_drop_until_all_cpus_valid;
    }
    pub inline fn getParsingMode(self: *const ResetTraceProcessorArgsReader) ResetTraceProcessorArgs.ParsingMode {
        return self._parsing_mode;
    }
    pub inline fn getSortingMode(self: *const ResetTraceProcessorArgsReader) ResetTraceProcessorArgs.SortingMode {
        return self._sorting_mode;
    }
    pub fn extraParsingDescriptorsCount(self: *const ResetTraceProcessorArgsReader) usize {
        return self._extra_parsing_descriptors_cnt;
    }
    pub fn extraParsingDescriptorsNext(self: *ResetTraceProcessorArgsReader) ?[]const u8 {
        if (self._extra_parsing_descriptors_offset == null) return null;
        const current_offset = self._extra_parsing_descriptors_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._extra_parsing_descriptors_last_offset != null and current_offset >= self._extra_parsing_descriptors_last_offset.?) {
            self._extra_parsing_descriptors_offset = null;
            return result.value;
        }
        if (self._extra_parsing_descriptors_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._extra_parsing_descriptors_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == ResetTraceProcessorArgsWire.EXTRA_PARSING_DESCRIPTORS_WIRE) {
                self._extra_parsing_descriptors_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._extra_parsing_descriptors_offset = null;
        return result.value;
    }
};
const RegisterSqlPackageArgsWire = struct {
    const PACKAGE_NAME_WIRE: gremlin.ProtoWireNumber = 1;
    const MODULES_WIRE: gremlin.ProtoWireNumber = 2;
    const ALLOW_OVERRIDE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const RegisterSqlPackageArgs = struct {
    // nested structs
    const ModuleWire = struct {
        const NAME_WIRE: gremlin.ProtoWireNumber = 1;
        const SQL_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Module = struct {
        // fields
        name: ?[]const u8 = null,
        sql: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const RegisterSqlPackageArgs.Module) usize {
            var res: usize = 0;
            if (self.name) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageArgs.ModuleWire.NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.sql) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageArgs.ModuleWire.SQL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const RegisterSqlPackageArgs.Module, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const RegisterSqlPackageArgs.Module, target: *gremlin.Writer) void {
            if (self.name) |v| {
                if (v.len > 0) {
                    target.appendBytes(RegisterSqlPackageArgs.ModuleWire.NAME_WIRE, v);
                }
            }
            if (self.sql) |v| {
                if (v.len > 0) {
                    target.appendBytes(RegisterSqlPackageArgs.ModuleWire.SQL_WIRE, v);
                }
            }
        }
    };
    pub const ModuleReader = struct {
        buf: gremlin.Reader,
        _name: ?[]const u8 = null,
        _sql: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!RegisterSqlPackageArgs.ModuleReader {
            const buf = gremlin.Reader.init(src);
            var res = RegisterSqlPackageArgs.ModuleReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    RegisterSqlPackageArgs.ModuleWire.NAME_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._name = result.value;
                    },
                    RegisterSqlPackageArgs.ModuleWire.SQL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sql = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getName(self: *const RegisterSqlPackageArgs.ModuleReader) []const u8 {
            return self._name orelse &[_]u8{};
        }
        pub inline fn getSql(self: *const RegisterSqlPackageArgs.ModuleReader) []const u8 {
            return self._sql orelse &[_]u8{};
        }
    };
    // fields
    package_name: ?[]const u8 = null,
    modules: ?[]const ?RegisterSqlPackageArgs.Module = null,
    allow_override: bool = false,
    pub fn calcProtobufSize(self: *const RegisterSqlPackageArgs) usize {
        var res: usize = 0;
        if (self.package_name) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageArgsWire.PACKAGE_NAME_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.modules) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageArgsWire.MODULES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.allow_override != false) {
            res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageArgsWire.ALLOW_OVERRIDE_WIRE) + gremlin.sizes.sizeBool(self.allow_override);
        }
        return res;
    }
    pub fn encode(self: *const RegisterSqlPackageArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RegisterSqlPackageArgs, target: *gremlin.Writer) void {
        if (self.package_name) |v| {
            if (v.len > 0) {
                target.appendBytes(RegisterSqlPackageArgsWire.PACKAGE_NAME_WIRE, v);
            }
        }
        if (self.modules) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(RegisterSqlPackageArgsWire.MODULES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(RegisterSqlPackageArgsWire.MODULES_WIRE, 0);
                }
            }
        }
        if (self.allow_override != false) {
            target.appendBool(RegisterSqlPackageArgsWire.ALLOW_OVERRIDE_WIRE, self.allow_override);
        }
    }
};
pub const RegisterSqlPackageArgsReader = struct {
    buf: gremlin.Reader,
    _package_name: ?[]const u8 = null,
    _modules_offset: ?usize = null,
    _modules_last_offset: ?usize = null,
    _modules_cnt: usize = 0,
    _allow_override: bool = false,
    pub fn init(src: []const u8) gremlin.Error!RegisterSqlPackageArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = RegisterSqlPackageArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RegisterSqlPackageArgsWire.PACKAGE_NAME_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._package_name = result.value;
                },
                RegisterSqlPackageArgsWire.MODULES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._modules_offset == null) {
                        res._modules_offset = offset - result.size;
                    }
                    res._modules_last_offset = offset;
                    res._modules_cnt += 1;
                },
                RegisterSqlPackageArgsWire.ALLOW_OVERRIDE_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._allow_override = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getPackageName(self: *const RegisterSqlPackageArgsReader) []const u8 {
        return self._package_name orelse &[_]u8{};
    }
    pub fn modulesCount(self: *const RegisterSqlPackageArgsReader) usize {
        return self._modules_cnt;
    }
    pub fn modulesNext(self: *RegisterSqlPackageArgsReader) ?RegisterSqlPackageArgs.ModuleReader {
        if (self._modules_offset == null) return null;
        const current_offset = self._modules_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = RegisterSqlPackageArgs.ModuleReader.init(result.value) catch return null;
        if (self._modules_last_offset != null and current_offset >= self._modules_last_offset.?) {
            self._modules_offset = null;
            return msg;
        }
        if (self._modules_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._modules_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == RegisterSqlPackageArgsWire.MODULES_WIRE) {
                self._modules_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._modules_offset = null;
        return msg;
    }
    pub inline fn getAllowOverride(self: *const RegisterSqlPackageArgsReader) bool {
        return self._allow_override;
    }
};
const RegisterSqlPackageResultWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const RegisterSqlPackageResult = struct {
    // fields
    error_: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const RegisterSqlPackageResult) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(RegisterSqlPackageResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const RegisterSqlPackageResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const RegisterSqlPackageResult, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(RegisterSqlPackageResultWire.ERROR_WIRE, v);
            }
        }
    }
};
pub const RegisterSqlPackageResultReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!RegisterSqlPackageResultReader {
        const buf = gremlin.Reader.init(src);
        var res = RegisterSqlPackageResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                RegisterSqlPackageResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const RegisterSqlPackageResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
};
const FinalizeDataResultWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const FinalizeDataResult = struct {
    // fields
    error_: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const FinalizeDataResult) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(FinalizeDataResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const FinalizeDataResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const FinalizeDataResult, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(FinalizeDataResultWire.ERROR_WIRE, v);
            }
        }
    }
};
pub const FinalizeDataResultReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!FinalizeDataResultReader {
        const buf = gremlin.Reader.init(src);
        var res = FinalizeDataResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                FinalizeDataResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const FinalizeDataResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
};
const AnalyzeStructuredQueryArgsWire = struct {
    const QUERIES_WIRE: gremlin.ProtoWireNumber = 1;
};
pub const AnalyzeStructuredQueryArgs = struct {
    // fields
    queries: ?[]const ?structured_query.PerfettoSqlStructuredQuery = null,
    pub fn calcProtobufSize(self: *const AnalyzeStructuredQueryArgs) usize {
        var res: usize = 0;
        if (self.queries) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryArgsWire.QUERIES_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AnalyzeStructuredQueryArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnalyzeStructuredQueryArgs, target: *gremlin.Writer) void {
        if (self.queries) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AnalyzeStructuredQueryArgsWire.QUERIES_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AnalyzeStructuredQueryArgsWire.QUERIES_WIRE, 0);
                }
            }
        }
    }
};
pub const AnalyzeStructuredQueryArgsReader = struct {
    buf: gremlin.Reader,
    _queries_offset: ?usize = null,
    _queries_last_offset: ?usize = null,
    _queries_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AnalyzeStructuredQueryArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = AnalyzeStructuredQueryArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnalyzeStructuredQueryArgsWire.QUERIES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._queries_offset == null) {
                        res._queries_offset = offset - result.size;
                    }
                    res._queries_last_offset = offset;
                    res._queries_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn queriesCount(self: *const AnalyzeStructuredQueryArgsReader) usize {
        return self._queries_cnt;
    }
    pub fn queriesNext(self: *AnalyzeStructuredQueryArgsReader) ?structured_query.PerfettoSqlStructuredQueryReader {
        if (self._queries_offset == null) return null;
        const current_offset = self._queries_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = structured_query.PerfettoSqlStructuredQueryReader.init(result.value) catch return null;
        if (self._queries_last_offset != null and current_offset >= self._queries_last_offset.?) {
            self._queries_offset = null;
            return msg;
        }
        if (self._queries_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._queries_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AnalyzeStructuredQueryArgsWire.QUERIES_WIRE) {
                self._queries_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._queries_offset = null;
        return msg;
    }
};
const AnalyzeStructuredQueryResultWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 1;
    const RESULTS_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const AnalyzeStructuredQueryResult = struct {
    // nested structs
    const StructuredQueryResultWire = struct {
        const SQL_WIRE: gremlin.ProtoWireNumber = 1;
        const TEXTPROTO_WIRE: gremlin.ProtoWireNumber = 4;
        const MODULES_WIRE: gremlin.ProtoWireNumber = 2;
        const PREAMBLES_WIRE: gremlin.ProtoWireNumber = 3;
        const COLUMNS_WIRE: gremlin.ProtoWireNumber = 5;
    };
    pub const StructuredQueryResult = struct {
        // fields
        sql: ?[]const u8 = null,
        textproto: ?[]const u8 = null,
        modules: ?[]const ?[]const u8 = null,
        preambles: ?[]const ?[]const u8 = null,
        columns: ?[]const ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const AnalyzeStructuredQueryResult.StructuredQueryResult) usize {
            var res: usize = 0;
            if (self.sql) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResult.StructuredQueryResultWire.SQL_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.textproto) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResult.StructuredQueryResultWire.TEXTPROTO_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.modules) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResult.StructuredQueryResultWire.MODULES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.preambles) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResult.StructuredQueryResultWire.PREAMBLES_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.columns) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResult.StructuredQueryResultWire.COLUMNS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            return res;
        }
        pub fn encode(self: *const AnalyzeStructuredQueryResult.StructuredQueryResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const AnalyzeStructuredQueryResult.StructuredQueryResult, target: *gremlin.Writer) void {
            if (self.sql) |v| {
                if (v.len > 0) {
                    target.appendBytes(AnalyzeStructuredQueryResult.StructuredQueryResultWire.SQL_WIRE, v);
                }
            }
            if (self.textproto) |v| {
                if (v.len > 0) {
                    target.appendBytes(AnalyzeStructuredQueryResult.StructuredQueryResultWire.TEXTPROTO_WIRE, v);
                }
            }
            if (self.modules) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AnalyzeStructuredQueryResult.StructuredQueryResultWire.MODULES_WIRE, v);
                    } else {
                        target.appendBytesTag(AnalyzeStructuredQueryResult.StructuredQueryResultWire.MODULES_WIRE, 0);
                    }
                }
            }
            if (self.preambles) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AnalyzeStructuredQueryResult.StructuredQueryResultWire.PREAMBLES_WIRE, v);
                    } else {
                        target.appendBytesTag(AnalyzeStructuredQueryResult.StructuredQueryResultWire.PREAMBLES_WIRE, 0);
                    }
                }
            }
            if (self.columns) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(AnalyzeStructuredQueryResult.StructuredQueryResultWire.COLUMNS_WIRE, v);
                    } else {
                        target.appendBytesTag(AnalyzeStructuredQueryResult.StructuredQueryResultWire.COLUMNS_WIRE, 0);
                    }
                }
            }
        }
    };
    pub const StructuredQueryResultReader = struct {
        buf: gremlin.Reader,
        _sql: ?[]const u8 = null,
        _textproto: ?[]const u8 = null,
        _modules_offset: ?usize = null,
        _modules_last_offset: ?usize = null,
        _modules_cnt: usize = 0,
        _preambles_offset: ?usize = null,
        _preambles_last_offset: ?usize = null,
        _preambles_cnt: usize = 0,
        _columns_offset: ?usize = null,
        _columns_last_offset: ?usize = null,
        _columns_cnt: usize = 0,
        pub fn init(src: []const u8) gremlin.Error!AnalyzeStructuredQueryResult.StructuredQueryResultReader {
            const buf = gremlin.Reader.init(src);
            var res = AnalyzeStructuredQueryResult.StructuredQueryResultReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    AnalyzeStructuredQueryResult.StructuredQueryResultWire.SQL_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sql = result.value;
                    },
                    AnalyzeStructuredQueryResult.StructuredQueryResultWire.TEXTPROTO_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._textproto = result.value;
                    },
                    AnalyzeStructuredQueryResult.StructuredQueryResultWire.MODULES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._modules_offset == null) {
                            res._modules_offset = offset - result.size;
                        }
                        res._modules_last_offset = offset;
                        res._modules_cnt += 1;
                    },
                    AnalyzeStructuredQueryResult.StructuredQueryResultWire.PREAMBLES_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._preambles_offset == null) {
                            res._preambles_offset = offset - result.size;
                        }
                        res._preambles_last_offset = offset;
                        res._preambles_cnt += 1;
                    },
                    AnalyzeStructuredQueryResult.StructuredQueryResultWire.COLUMNS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._columns_offset == null) {
                            res._columns_offset = offset - result.size;
                        }
                        res._columns_last_offset = offset;
                        res._columns_cnt += 1;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSql(self: *const AnalyzeStructuredQueryResult.StructuredQueryResultReader) []const u8 {
            return self._sql orelse &[_]u8{};
        }
        pub inline fn getTextproto(self: *const AnalyzeStructuredQueryResult.StructuredQueryResultReader) []const u8 {
            return self._textproto orelse &[_]u8{};
        }
        pub fn modulesCount(self: *const AnalyzeStructuredQueryResult.StructuredQueryResultReader) usize {
            return self._modules_cnt;
        }
        pub fn modulesNext(self: *AnalyzeStructuredQueryResult.StructuredQueryResultReader) ?[]const u8 {
            if (self._modules_offset == null) return null;
            const current_offset = self._modules_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._modules_last_offset != null and current_offset >= self._modules_last_offset.?) {
                self._modules_offset = null;
                return result.value;
            }
            if (self._modules_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._modules_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AnalyzeStructuredQueryResult.StructuredQueryResultWire.MODULES_WIRE) {
                    self._modules_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._modules_offset = null;
            return result.value;
        }
        pub fn preamblesCount(self: *const AnalyzeStructuredQueryResult.StructuredQueryResultReader) usize {
            return self._preambles_cnt;
        }
        pub fn preamblesNext(self: *AnalyzeStructuredQueryResult.StructuredQueryResultReader) ?[]const u8 {
            if (self._preambles_offset == null) return null;
            const current_offset = self._preambles_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._preambles_last_offset != null and current_offset >= self._preambles_last_offset.?) {
                self._preambles_offset = null;
                return result.value;
            }
            if (self._preambles_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._preambles_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AnalyzeStructuredQueryResult.StructuredQueryResultWire.PREAMBLES_WIRE) {
                    self._preambles_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._preambles_offset = null;
            return result.value;
        }
        pub fn columnsCount(self: *const AnalyzeStructuredQueryResult.StructuredQueryResultReader) usize {
            return self._columns_cnt;
        }
        pub fn columnsNext(self: *AnalyzeStructuredQueryResult.StructuredQueryResultReader) ?[]const u8 {
            if (self._columns_offset == null) return null;
            const current_offset = self._columns_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._columns_last_offset != null and current_offset >= self._columns_last_offset.?) {
                self._columns_offset = null;
                return result.value;
            }
            if (self._columns_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._columns_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == AnalyzeStructuredQueryResult.StructuredQueryResultWire.COLUMNS_WIRE) {
                    self._columns_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._columns_offset = null;
            return result.value;
        }
    };
    // fields
    error_: ?[]const u8 = null,
    results: ?[]const ?AnalyzeStructuredQueryResult.StructuredQueryResult = null,
    pub fn calcProtobufSize(self: *const AnalyzeStructuredQueryResult) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.results) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(AnalyzeStructuredQueryResultWire.RESULTS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        return res;
    }
    pub fn encode(self: *const AnalyzeStructuredQueryResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const AnalyzeStructuredQueryResult, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(AnalyzeStructuredQueryResultWire.ERROR_WIRE, v);
            }
        }
        if (self.results) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(AnalyzeStructuredQueryResultWire.RESULTS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(AnalyzeStructuredQueryResultWire.RESULTS_WIRE, 0);
                }
            }
        }
    }
};
pub const AnalyzeStructuredQueryResultReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    _results_offset: ?usize = null,
    _results_last_offset: ?usize = null,
    _results_cnt: usize = 0,
    pub fn init(src: []const u8) gremlin.Error!AnalyzeStructuredQueryResultReader {
        const buf = gremlin.Reader.init(src);
        var res = AnalyzeStructuredQueryResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                AnalyzeStructuredQueryResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                AnalyzeStructuredQueryResultWire.RESULTS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._results_offset == null) {
                        res._results_offset = offset - result.size;
                    }
                    res._results_last_offset = offset;
                    res._results_cnt += 1;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const AnalyzeStructuredQueryResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub fn resultsCount(self: *const AnalyzeStructuredQueryResultReader) usize {
        return self._results_cnt;
    }
    pub fn resultsNext(self: *AnalyzeStructuredQueryResultReader) ?AnalyzeStructuredQueryResult.StructuredQueryResultReader {
        if (self._results_offset == null) return null;
        const current_offset = self._results_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = AnalyzeStructuredQueryResult.StructuredQueryResultReader.init(result.value) catch return null;
        if (self._results_last_offset != null and current_offset >= self._results_last_offset.?) {
            self._results_offset = null;
            return msg;
        }
        if (self._results_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._results_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == AnalyzeStructuredQueryResultWire.RESULTS_WIRE) {
                self._results_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._results_offset = null;
        return msg;
    }
};
const TraceSummaryArgsWire = struct {
    const PROTO_SPECS_WIRE: gremlin.ProtoWireNumber = 1;
    const TEXTPROTO_SPECS_WIRE: gremlin.ProtoWireNumber = 2;
    const COMPUTATION_SPEC_WIRE: gremlin.ProtoWireNumber = 3;
    const OUTPUT_FORMAT_WIRE: gremlin.ProtoWireNumber = 4;
};
pub const TraceSummaryArgs = struct {
    // nested enums
    pub const Format = enum(i32) {
        BINARY_PROTOBUF = 0,
        TEXTPROTO = 1,
    };
    // nested structs
    const ComputationSpecWire = struct {
        const METRIC_IDS_WIRE: gremlin.ProtoWireNumber = 1;
        const RUN_ALL_METRICS_WIRE: gremlin.ProtoWireNumber = 3;
        const METADATA_QUERY_ID_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const ComputationSpec = struct {
        // fields
        metric_ids: ?[]const ?[]const u8 = null,
        run_all_metrics: bool = false,
        metadata_query_id: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TraceSummaryArgs.ComputationSpec) usize {
            var res: usize = 0;
            if (self.metric_ids) |arr| {
                for (arr) |maybe_v| {
                    res += gremlin.sizes.sizeWireNumber(TraceSummaryArgs.ComputationSpecWire.METRIC_IDS_WIRE);
                    if (maybe_v) |v| {
                        res += gremlin.sizes.sizeUsize(v.len) + v.len;
                    } else {
                        res += gremlin.sizes.sizeUsize(0);
                    }
                }
            }
            if (self.run_all_metrics != false) {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryArgs.ComputationSpecWire.RUN_ALL_METRICS_WIRE) + gremlin.sizes.sizeBool(self.run_all_metrics);
            }
            if (self.metadata_query_id) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TraceSummaryArgs.ComputationSpecWire.METADATA_QUERY_ID_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TraceSummaryArgs.ComputationSpec, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TraceSummaryArgs.ComputationSpec, target: *gremlin.Writer) void {
            if (self.metric_ids) |arr| {
                for (arr) |maybe_v| {
                    if (maybe_v) |v| {
                        target.appendBytes(TraceSummaryArgs.ComputationSpecWire.METRIC_IDS_WIRE, v);
                    } else {
                        target.appendBytesTag(TraceSummaryArgs.ComputationSpecWire.METRIC_IDS_WIRE, 0);
                    }
                }
            }
            if (self.run_all_metrics != false) {
                target.appendBool(TraceSummaryArgs.ComputationSpecWire.RUN_ALL_METRICS_WIRE, self.run_all_metrics);
            }
            if (self.metadata_query_id) |v| {
                if (v.len > 0) {
                    target.appendBytes(TraceSummaryArgs.ComputationSpecWire.METADATA_QUERY_ID_WIRE, v);
                }
            }
        }
    };
    pub const ComputationSpecReader = struct {
        buf: gremlin.Reader,
        _metric_ids_offset: ?usize = null,
        _metric_ids_last_offset: ?usize = null,
        _metric_ids_cnt: usize = 0,
        _run_all_metrics: bool = false,
        _metadata_query_id: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TraceSummaryArgs.ComputationSpecReader {
            const buf = gremlin.Reader.init(src);
            var res = TraceSummaryArgs.ComputationSpecReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TraceSummaryArgs.ComputationSpecWire.METRIC_IDS_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        if (res._metric_ids_offset == null) {
                            res._metric_ids_offset = offset - result.size;
                        }
                        res._metric_ids_last_offset = offset;
                        res._metric_ids_cnt += 1;
                    },
                    TraceSummaryArgs.ComputationSpecWire.RUN_ALL_METRICS_WIRE => {
                        const result = try buf.readBool(offset);
                        offset += result.size;
                        res._run_all_metrics = result.value;
                    },
                    TraceSummaryArgs.ComputationSpecWire.METADATA_QUERY_ID_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._metadata_query_id = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn metricIdsCount(self: *const TraceSummaryArgs.ComputationSpecReader) usize {
            return self._metric_ids_cnt;
        }
        pub fn metricIdsNext(self: *TraceSummaryArgs.ComputationSpecReader) ?[]const u8 {
            if (self._metric_ids_offset == null) return null;
            const current_offset = self._metric_ids_offset.?;
            const result = self.buf.readBytes(current_offset) catch return null;
            if (self._metric_ids_last_offset != null and current_offset >= self._metric_ids_last_offset.?) {
                self._metric_ids_offset = null;
                return result.value;
            }
            if (self._metric_ids_last_offset == null) unreachable;
            var next_offset = current_offset + result.size;
            const max_offset = self._metric_ids_last_offset.?;
            while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
                const tag = self.buf.readTagAt(next_offset) catch break;
                next_offset += tag.size;
                if (tag.number == TraceSummaryArgs.ComputationSpecWire.METRIC_IDS_WIRE) {
                    self._metric_ids_offset = next_offset;
                    return result.value;
                } else {
                    next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
                }
            }
            self._metric_ids_offset = null;
            return result.value;
        }
        pub inline fn getRunAllMetrics(self: *const TraceSummaryArgs.ComputationSpecReader) bool {
            return self._run_all_metrics;
        }
        pub inline fn getMetadataQueryId(self: *const TraceSummaryArgs.ComputationSpecReader) []const u8 {
            return self._metadata_query_id orelse &[_]u8{};
        }
    };
    // fields
    proto_specs: ?[]const ?file.TraceSummarySpec = null,
    textproto_specs: ?[]const ?[]const u8 = null,
    computation_spec: ?TraceSummaryArgs.ComputationSpec = null,
    output_format: TraceSummaryArgs.Format = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const TraceSummaryArgs) usize {
        var res: usize = 0;
        if (self.proto_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryArgsWire.PROTO_SPECS_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.textproto_specs) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryArgsWire.TEXTPROTO_SPECS_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.computation_spec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryArgsWire.COMPUTATION_SPEC_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.output_format) != 0) {
            res += gremlin.sizes.sizeWireNumber(TraceSummaryArgsWire.OUTPUT_FORMAT_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.output_format));
        }
        return res;
    }
    pub fn encode(self: *const TraceSummaryArgs, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceSummaryArgs, target: *gremlin.Writer) void {
        if (self.proto_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TraceSummaryArgsWire.PROTO_SPECS_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TraceSummaryArgsWire.PROTO_SPECS_WIRE, 0);
                }
            }
        }
        if (self.textproto_specs) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TraceSummaryArgsWire.TEXTPROTO_SPECS_WIRE, v);
                } else {
                    target.appendBytesTag(TraceSummaryArgsWire.TEXTPROTO_SPECS_WIRE, 0);
                }
            }
        }
        if (self.computation_spec) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TraceSummaryArgsWire.COMPUTATION_SPEC_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.output_format) != 0) {
            target.appendInt32(TraceSummaryArgsWire.OUTPUT_FORMAT_WIRE, @intFromEnum(self.output_format));
        }
    }
};
pub const TraceSummaryArgsReader = struct {
    buf: gremlin.Reader,
    _proto_specs_offset: ?usize = null,
    _proto_specs_last_offset: ?usize = null,
    _proto_specs_cnt: usize = 0,
    _textproto_specs_offset: ?usize = null,
    _textproto_specs_last_offset: ?usize = null,
    _textproto_specs_cnt: usize = 0,
    _computation_spec_buf: ?[]const u8 = null,
    _output_format: TraceSummaryArgs.Format = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!TraceSummaryArgsReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceSummaryArgsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceSummaryArgsWire.PROTO_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._proto_specs_offset == null) {
                        res._proto_specs_offset = offset - result.size;
                    }
                    res._proto_specs_last_offset = offset;
                    res._proto_specs_cnt += 1;
                },
                TraceSummaryArgsWire.TEXTPROTO_SPECS_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._textproto_specs_offset == null) {
                        res._textproto_specs_offset = offset - result.size;
                    }
                    res._textproto_specs_last_offset = offset;
                    res._textproto_specs_cnt += 1;
                },
                TraceSummaryArgsWire.COMPUTATION_SPEC_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._computation_spec_buf = result.value;
                },
                TraceSummaryArgsWire.OUTPUT_FORMAT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._output_format = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn protoSpecsCount(self: *const TraceSummaryArgsReader) usize {
        return self._proto_specs_cnt;
    }
    pub fn protoSpecsNext(self: *TraceSummaryArgsReader) ?file.TraceSummarySpecReader {
        if (self._proto_specs_offset == null) return null;
        const current_offset = self._proto_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = file.TraceSummarySpecReader.init(result.value) catch return null;
        if (self._proto_specs_last_offset != null and current_offset >= self._proto_specs_last_offset.?) {
            self._proto_specs_offset = null;
            return msg;
        }
        if (self._proto_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._proto_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceSummaryArgsWire.PROTO_SPECS_WIRE) {
                self._proto_specs_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._proto_specs_offset = null;
        return msg;
    }
    pub fn textprotoSpecsCount(self: *const TraceSummaryArgsReader) usize {
        return self._textproto_specs_cnt;
    }
    pub fn textprotoSpecsNext(self: *TraceSummaryArgsReader) ?[]const u8 {
        if (self._textproto_specs_offset == null) return null;
        const current_offset = self._textproto_specs_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._textproto_specs_last_offset != null and current_offset >= self._textproto_specs_last_offset.?) {
            self._textproto_specs_offset = null;
            return result.value;
        }
        if (self._textproto_specs_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._textproto_specs_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TraceSummaryArgsWire.TEXTPROTO_SPECS_WIRE) {
                self._textproto_specs_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._textproto_specs_offset = null;
        return result.value;
    }
    pub fn getComputationSpec(self: *const TraceSummaryArgsReader) gremlin.Error!TraceSummaryArgs.ComputationSpecReader {
        if (self._computation_spec_buf) |buf| {
            return try TraceSummaryArgs.ComputationSpecReader.init(buf);
        }
        return try TraceSummaryArgs.ComputationSpecReader.init(&[_]u8{});
    }
    pub inline fn getOutputFormat(self: *const TraceSummaryArgsReader) TraceSummaryArgs.Format {
        return self._output_format;
    }
};
const TraceSummaryResultWire = struct {
    const ERROR_WIRE: gremlin.ProtoWireNumber = 3;
    const PROTO_SUMMARY_WIRE: gremlin.ProtoWireNumber = 1;
    const TEXTPROTO_SUMMARY_WIRE: gremlin.ProtoWireNumber = 2;
};
pub const TraceSummaryResult = struct {
    // fields
    error_: ?[]const u8 = null,
    proto_summary: ?[]const u8 = null,
    textproto_summary: ?[]const u8 = null,
    pub fn calcProtobufSize(self: *const TraceSummaryResult) usize {
        var res: usize = 0;
        if (self.error_) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryResultWire.ERROR_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.proto_summary) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryResultWire.PROTO_SUMMARY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.textproto_summary) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TraceSummaryResultWire.TEXTPROTO_SUMMARY_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        return res;
    }
    pub fn encode(self: *const TraceSummaryResult, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TraceSummaryResult, target: *gremlin.Writer) void {
        if (self.error_) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceSummaryResultWire.ERROR_WIRE, v);
            }
        }
        if (self.proto_summary) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceSummaryResultWire.PROTO_SUMMARY_WIRE, v);
            }
        }
        if (self.textproto_summary) |v| {
            if (v.len > 0) {
                target.appendBytes(TraceSummaryResultWire.TEXTPROTO_SUMMARY_WIRE, v);
            }
        }
    }
};
pub const TraceSummaryResultReader = struct {
    buf: gremlin.Reader,
    _error_: ?[]const u8 = null,
    _proto_summary: ?[]const u8 = null,
    _textproto_summary: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TraceSummaryResultReader {
        const buf = gremlin.Reader.init(src);
        var res = TraceSummaryResultReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TraceSummaryResultWire.ERROR_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._error_ = result.value;
                },
                TraceSummaryResultWire.PROTO_SUMMARY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._proto_summary = result.value;
                },
                TraceSummaryResultWire.TEXTPROTO_SUMMARY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._textproto_summary = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getError(self: *const TraceSummaryResultReader) []const u8 {
        return self._error_ orelse &[_]u8{};
    }
    pub inline fn getProtoSummary(self: *const TraceSummaryResultReader) []const u8 {
        return self._proto_summary orelse &[_]u8{};
    }
    pub inline fn getTextprotoSummary(self: *const TraceSummaryResultReader) []const u8 {
        return self._textproto_summary orelse &[_]u8{};
    }
};
