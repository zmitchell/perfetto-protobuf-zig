// =============================================================================
// DO NOT EDIT - This file is automatically generated by gremlin.zig
// =============================================================================
const std = @import("std");
const gremlin = @import("gremlin");
const library = @import("library.proto.zig");
const test_messages = @import("src/gen/src/protozero/test/example_proto/subpackage/test_messages.proto.zig");
const test_messages = @import("src/gen/src/protozero/test/example_proto/other_package/test_messages.proto.zig");
// enums
pub const SmallEnum = enum(i32) {
    TO_BE = 1,
    NOT_TO_BE = 0,
};
pub const SignedEnum = enum(i32) {
    POSITIVE = 1,
    NEUTRAL = 0,
    NEGATIVE = -1,
};
pub const BigEnum = enum(i32) {
    BEGIN = 10,
    END = 100500,
    _PROTOBUF_UNKNOWN = 0,
};
pub const VeryNegativeEnum = enum(i32) {
    DEF = 0,
    VAL = -2147483648,
};
// structs
const TransgalacticParcelWire = struct {
    const MESSAGE_WIRE: gremlin.ProtoWireNumber = 1;
    const TRACKING_CODE_WIRE: gremlin.ProtoWireNumber = 2;
    const MESSAGE_TYPE_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const TransgalacticParcel = struct {
    // fields
    message: ?library.TransgalacticMessage = null,
    tracking_code: ?[]const u8 = null,
    message_type: library.TransgalacticMessage.MessageType = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const TransgalacticParcel) usize {
        var res: usize = 0;
        if (self.message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TransgalacticParcelWire.MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.tracking_code) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TransgalacticParcelWire.TRACKING_CODE_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.message_type) != 0) {
            res += gremlin.sizes.sizeWireNumber(TransgalacticParcelWire.MESSAGE_TYPE_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.message_type));
        }
        return res;
    }
    pub fn encode(self: *const TransgalacticParcel, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TransgalacticParcel, target: *gremlin.Writer) void {
        if (self.message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TransgalacticParcelWire.MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.tracking_code) |v| {
            if (v.len > 0) {
                target.appendBytes(TransgalacticParcelWire.TRACKING_CODE_WIRE, v);
            }
        }
        if (@intFromEnum(self.message_type) != 0) {
            target.appendInt32(TransgalacticParcelWire.MESSAGE_TYPE_WIRE, @intFromEnum(self.message_type));
        }
    }
};
pub const TransgalacticParcelReader = struct {
    buf: gremlin.Reader,
    _message_buf: ?[]const u8 = null,
    _tracking_code: ?[]const u8 = null,
    _message_type: library.TransgalacticMessage.MessageType = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!TransgalacticParcelReader {
        const buf = gremlin.Reader.init(src);
        var res = TransgalacticParcelReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TransgalacticParcelWire.MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._message_buf = result.value;
                },
                TransgalacticParcelWire.TRACKING_CODE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._tracking_code = result.value;
                },
                TransgalacticParcelWire.MESSAGE_TYPE_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._message_type = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getMessage(self: *const TransgalacticParcelReader) gremlin.Error!library.TransgalacticMessageReader {
        if (self._message_buf) |buf| {
            return try library.TransgalacticMessageReader.init(buf);
        }
        return try library.TransgalacticMessageReader.init(&[_]u8{});
    }
    pub inline fn getTrackingCode(self: *const TransgalacticParcelReader) []const u8 {
        return self._tracking_code orelse &[_]u8{};
    }
    pub inline fn getMessageType(self: *const TransgalacticParcelReader) library.TransgalacticMessage.MessageType {
        return self._message_type;
    }
};
const EveryFieldWire = struct {
    const FIELD_INT32_WIRE: gremlin.ProtoWireNumber = 1;
    const FIELD_INT64_WIRE: gremlin.ProtoWireNumber = 2;
    const FIELD_UINT32_WIRE: gremlin.ProtoWireNumber = 3;
    const FIELD_UINT64_WIRE: gremlin.ProtoWireNumber = 4;
    const FIELD_SINT32_WIRE: gremlin.ProtoWireNumber = 5;
    const FIELD_SINT64_WIRE: gremlin.ProtoWireNumber = 6;
    const FIELD_FIXED32_WIRE: gremlin.ProtoWireNumber = 7;
    const FIELD_FIXED64_WIRE: gremlin.ProtoWireNumber = 8;
    const FIELD_SFIXED32_WIRE: gremlin.ProtoWireNumber = 9;
    const FIELD_SFIXED64_WIRE: gremlin.ProtoWireNumber = 10;
    const FIELD_FLOAT_WIRE: gremlin.ProtoWireNumber = 11;
    const FIELD_DOUBLE_WIRE: gremlin.ProtoWireNumber = 12;
    const FIELD_BOOL_WIRE: gremlin.ProtoWireNumber = 13;
    const FIELD_NESTED_WIRE: gremlin.ProtoWireNumber = 14;
    const SMALL_ENUM_WIRE: gremlin.ProtoWireNumber = 51;
    const SIGNED_ENUM_WIRE: gremlin.ProtoWireNumber = 52;
    const BIG_ENUM_WIRE: gremlin.ProtoWireNumber = 53;
    const VERY_NEGATIVE_ENUM_WIRE: gremlin.ProtoWireNumber = 54;
    const FIELD_STRING_WIRE: gremlin.ProtoWireNumber = 500;
    const FIELD_BYTES_WIRE: gremlin.ProtoWireNumber = 505;
    const NESTED_ENUM_WIRE: gremlin.ProtoWireNumber = 600;
    const REPEATED_STRING_WIRE: gremlin.ProtoWireNumber = 700;
    const REPEATED_FIXED64_WIRE: gremlin.ProtoWireNumber = 701;
    const REPEATED_SFIXED32_WIRE: gremlin.ProtoWireNumber = 702;
    const REPEATED_INT32_WIRE: gremlin.ProtoWireNumber = 999;
};
pub const EveryField = struct {
    // nested enums
    pub const NestedEnum = enum(i32) {
        PING = 1,
        PONG = 2,
        _PROTOBUF_UNKNOWN = 0,
    };
    // fields
    field_int32: i32 = 0,
    field_int64: i64 = 0,
    field_uint32: u32 = 0,
    field_uint64: u64 = 0,
    field_sint32: i32 = 0,
    field_sint64: i64 = 0,
    field_fixed32: u32 = 0,
    field_fixed64: u64 = 0,
    field_sfixed32: i32 = 0,
    field_sfixed64: i64 = 0,
    field_float: f32 = 0.0,
    field_double: f64 = 0.0,
    field_bool: bool = false,
    field_nested: ?[]const ?EveryField = null,
    small_enum: SmallEnum = @enumFromInt(0),
    signed_enum: SignedEnum = @enumFromInt(0),
    big_enum: BigEnum = @enumFromInt(0),
    very_negative_enum: VeryNegativeEnum = @enumFromInt(0),
    field_string: ?[]const u8 = null,
    field_bytes: ?[]const u8 = null,
    nested_enum: EveryField.NestedEnum = @enumFromInt(0),
    repeated_string: ?[]const ?[]const u8 = null,
    repeated_fixed64: ?[]const u64 = null,
    repeated_sfixed32: ?[]const i32 = null,
    repeated_int32: ?[]const i32 = null,
    pub fn calcProtobufSize(self: *const EveryField) usize {
        var res: usize = 0;
        if (self.field_int32 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_INT32_WIRE) + gremlin.sizes.sizeI32(self.field_int32);
        }
        if (self.field_int64 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_INT64_WIRE) + gremlin.sizes.sizeI64(self.field_int64);
        }
        if (self.field_uint32 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_UINT32_WIRE) + gremlin.sizes.sizeU32(self.field_uint32);
        }
        if (self.field_uint64 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_UINT64_WIRE) + gremlin.sizes.sizeU64(self.field_uint64);
        }
        if (self.field_sint32 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_SINT32_WIRE) + gremlin.sizes.sizeSI32(self.field_sint32);
        }
        if (self.field_sint64 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_SINT64_WIRE) + gremlin.sizes.sizeSI64(self.field_sint64);
        }
        if (self.field_fixed32 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_FIXED32_WIRE) + gremlin.sizes.sizeFixed32(self.field_fixed32);
        }
        if (self.field_fixed64 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_FIXED64_WIRE) + gremlin.sizes.sizeFixed64(self.field_fixed64);
        }
        if (self.field_sfixed32 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_SFIXED32_WIRE) + gremlin.sizes.sizeSFixed32(self.field_sfixed32);
        }
        if (self.field_sfixed64 != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_SFIXED64_WIRE) + gremlin.sizes.sizeSFixed64(self.field_sfixed64);
        }
        if (self.field_float != 0.0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_FLOAT_WIRE) + gremlin.sizes.sizeFloat(self.field_float);
        }
        if (self.field_double != 0.0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_DOUBLE_WIRE) + gremlin.sizes.sizeDouble(self.field_double);
        }
        if (self.field_bool != false) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_BOOL_WIRE) + gremlin.sizes.sizeBool(self.field_bool);
        }
        if (self.field_nested) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_NESTED_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (@intFromEnum(self.small_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.SMALL_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.small_enum));
        }
        if (@intFromEnum(self.signed_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.SIGNED_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.signed_enum));
        }
        if (@intFromEnum(self.big_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.BIG_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.big_enum));
        }
        if (@intFromEnum(self.very_negative_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.VERY_NEGATIVE_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.very_negative_enum));
        }
        if (self.field_string) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.field_bytes) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.FIELD_BYTES_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (@intFromEnum(self.nested_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(EveryFieldWire.NESTED_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.nested_enum));
        }
        if (self.repeated_string) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_STRING_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.repeated_fixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_FIXED64_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_FIXED64_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.repeated_sfixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_SFIXED32_WIRE) + gremlin.sizes.sizeSFixed32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed32(v);
                }
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_SFIXED32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.repeated_int32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_INT32_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(EveryFieldWire.REPEATED_INT32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const EveryField, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const EveryField, target: *gremlin.Writer) void {
        if (self.field_int32 != 0) {
            target.appendInt32(EveryFieldWire.FIELD_INT32_WIRE, self.field_int32);
        }
        if (self.field_int64 != 0) {
            target.appendInt64(EveryFieldWire.FIELD_INT64_WIRE, self.field_int64);
        }
        if (self.field_uint32 != 0) {
            target.appendUint32(EveryFieldWire.FIELD_UINT32_WIRE, self.field_uint32);
        }
        if (self.field_uint64 != 0) {
            target.appendUint64(EveryFieldWire.FIELD_UINT64_WIRE, self.field_uint64);
        }
        if (self.field_sint32 != 0) {
            target.appendSint32(EveryFieldWire.FIELD_SINT32_WIRE, self.field_sint32);
        }
        if (self.field_sint64 != 0) {
            target.appendSint64(EveryFieldWire.FIELD_SINT64_WIRE, self.field_sint64);
        }
        if (self.field_fixed32 != 0) {
            target.appendFixed32(EveryFieldWire.FIELD_FIXED32_WIRE, self.field_fixed32);
        }
        if (self.field_fixed64 != 0) {
            target.appendFixed64(EveryFieldWire.FIELD_FIXED64_WIRE, self.field_fixed64);
        }
        if (self.field_sfixed32 != 0) {
            target.appendSfixed32(EveryFieldWire.FIELD_SFIXED32_WIRE, self.field_sfixed32);
        }
        if (self.field_sfixed64 != 0) {
            target.appendSfixed64(EveryFieldWire.FIELD_SFIXED64_WIRE, self.field_sfixed64);
        }
        if (self.field_float != 0.0) {
            target.appendFloat32(EveryFieldWire.FIELD_FLOAT_WIRE, self.field_float);
        }
        if (self.field_double != 0.0) {
            target.appendFloat64(EveryFieldWire.FIELD_DOUBLE_WIRE, self.field_double);
        }
        if (self.field_bool != false) {
            target.appendBool(EveryFieldWire.FIELD_BOOL_WIRE, self.field_bool);
        }
        if (self.field_nested) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(EveryFieldWire.FIELD_NESTED_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(EveryFieldWire.FIELD_NESTED_WIRE, 0);
                }
            }
        }
        if (@intFromEnum(self.small_enum) != 0) {
            target.appendInt32(EveryFieldWire.SMALL_ENUM_WIRE, @intFromEnum(self.small_enum));
        }
        if (@intFromEnum(self.signed_enum) != 0) {
            target.appendInt32(EveryFieldWire.SIGNED_ENUM_WIRE, @intFromEnum(self.signed_enum));
        }
        if (@intFromEnum(self.big_enum) != 0) {
            target.appendInt32(EveryFieldWire.BIG_ENUM_WIRE, @intFromEnum(self.big_enum));
        }
        if (@intFromEnum(self.very_negative_enum) != 0) {
            target.appendInt32(EveryFieldWire.VERY_NEGATIVE_ENUM_WIRE, @intFromEnum(self.very_negative_enum));
        }
        if (self.field_string) |v| {
            if (v.len > 0) {
                target.appendBytes(EveryFieldWire.FIELD_STRING_WIRE, v);
            }
        }
        if (self.field_bytes) |v| {
            if (v.len > 0) {
                target.appendBytes(EveryFieldWire.FIELD_BYTES_WIRE, v);
            }
        }
        if (@intFromEnum(self.nested_enum) != 0) {
            target.appendInt32(EveryFieldWire.NESTED_ENUM_WIRE, @intFromEnum(self.nested_enum));
        }
        if (self.repeated_string) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(EveryFieldWire.REPEATED_STRING_WIRE, v);
                } else {
                    target.appendBytesTag(EveryFieldWire.REPEATED_STRING_WIRE, 0);
                }
            }
        }
        if (self.repeated_fixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(EveryFieldWire.REPEATED_FIXED64_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(EveryFieldWire.REPEATED_FIXED64_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.repeated_sfixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendSfixed32(EveryFieldWire.REPEATED_SFIXED32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed32(v);
                }
                target.appendBytesTag(EveryFieldWire.REPEATED_SFIXED32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendSfixed32WithoutTag(v);
                }
            }
        }
        if (self.repeated_int32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(EveryFieldWire.REPEATED_INT32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(EveryFieldWire.REPEATED_INT32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
    }
};
pub const EveryFieldReader = struct {
    buf: gremlin.Reader,
    _field_int32: i32 = 0,
    _field_int64: i64 = 0,
    _field_uint32: u32 = 0,
    _field_uint64: u64 = 0,
    _field_sint32: i32 = 0,
    _field_sint64: i64 = 0,
    _field_fixed32: u32 = 0,
    _field_fixed64: u64 = 0,
    _field_sfixed32: i32 = 0,
    _field_sfixed64: i64 = 0,
    _field_float: f32 = 0.0,
    _field_double: f64 = 0.0,
    _field_bool: bool = false,
    _field_nested_offset: ?usize = null,
    _field_nested_last_offset: ?usize = null,
    _field_nested_cnt: usize = 0,
    _small_enum: SmallEnum = @enumFromInt(0),
    _signed_enum: SignedEnum = @enumFromInt(0),
    _big_enum: BigEnum = @enumFromInt(0),
    _very_negative_enum: VeryNegativeEnum = @enumFromInt(0),
    _field_string: ?[]const u8 = null,
    _field_bytes: ?[]const u8 = null,
    _nested_enum: EveryField.NestedEnum = @enumFromInt(0),
    _repeated_string_offset: ?usize = null,
    _repeated_string_last_offset: ?usize = null,
    _repeated_string_cnt: usize = 0,
    _repeated_fixed64_offset: ?usize = null,
    _repeated_fixed64_last_offset: ?usize = null,
    _repeated_fixed64_packed: bool = false,
    _repeated_sfixed32_offset: ?usize = null,
    _repeated_sfixed32_last_offset: ?usize = null,
    _repeated_sfixed32_packed: bool = false,
    _repeated_int32_offset: ?usize = null,
    _repeated_int32_last_offset: ?usize = null,
    _repeated_int32_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!EveryFieldReader {
        const buf = gremlin.Reader.init(src);
        var res = EveryFieldReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                EveryFieldWire.FIELD_INT32_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._field_int32 = result.value;
                },
                EveryFieldWire.FIELD_INT64_WIRE => {
                    const result = try buf.readInt64(offset);
                    offset += result.size;
                    res._field_int64 = result.value;
                },
                EveryFieldWire.FIELD_UINT32_WIRE => {
                    const result = try buf.readUInt32(offset);
                    offset += result.size;
                    res._field_uint32 = result.value;
                },
                EveryFieldWire.FIELD_UINT64_WIRE => {
                    const result = try buf.readUInt64(offset);
                    offset += result.size;
                    res._field_uint64 = result.value;
                },
                EveryFieldWire.FIELD_SINT32_WIRE => {
                    const result = try buf.readSInt32(offset);
                    offset += result.size;
                    res._field_sint32 = result.value;
                },
                EveryFieldWire.FIELD_SINT64_WIRE => {
                    const result = try buf.readSInt64(offset);
                    offset += result.size;
                    res._field_sint64 = result.value;
                },
                EveryFieldWire.FIELD_FIXED32_WIRE => {
                    const result = try buf.readFixed32(offset);
                    offset += result.size;
                    res._field_fixed32 = result.value;
                },
                EveryFieldWire.FIELD_FIXED64_WIRE => {
                    const result = try buf.readFixed64(offset);
                    offset += result.size;
                    res._field_fixed64 = result.value;
                },
                EveryFieldWire.FIELD_SFIXED32_WIRE => {
                    const result = try buf.readSFixed32(offset);
                    offset += result.size;
                    res._field_sfixed32 = result.value;
                },
                EveryFieldWire.FIELD_SFIXED64_WIRE => {
                    const result = try buf.readSFixed64(offset);
                    offset += result.size;
                    res._field_sfixed64 = result.value;
                },
                EveryFieldWire.FIELD_FLOAT_WIRE => {
                    const result = try buf.readFloat32(offset);
                    offset += result.size;
                    res._field_float = result.value;
                },
                EveryFieldWire.FIELD_DOUBLE_WIRE => {
                    const result = try buf.readFloat64(offset);
                    offset += result.size;
                    res._field_double = result.value;
                },
                EveryFieldWire.FIELD_BOOL_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._field_bool = result.value;
                },
                EveryFieldWire.FIELD_NESTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._field_nested_offset == null) {
                        res._field_nested_offset = offset - result.size;
                    }
                    res._field_nested_last_offset = offset;
                    res._field_nested_cnt += 1;
                },
                EveryFieldWire.SMALL_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._small_enum = @enumFromInt(result.value);
                },
                EveryFieldWire.SIGNED_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._signed_enum = @enumFromInt(result.value);
                },
                EveryFieldWire.BIG_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._big_enum = @enumFromInt(result.value);
                },
                EveryFieldWire.VERY_NEGATIVE_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._very_negative_enum = @enumFromInt(result.value);
                },
                EveryFieldWire.FIELD_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._field_string = result.value;
                },
                EveryFieldWire.FIELD_BYTES_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._field_bytes = result.value;
                },
                EveryFieldWire.NESTED_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._nested_enum = @enumFromInt(result.value);
                },
                EveryFieldWire.REPEATED_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._repeated_string_offset == null) {
                        res._repeated_string_offset = offset - result.size;
                    }
                    res._repeated_string_last_offset = offset;
                    res._repeated_string_cnt += 1;
                },
                EveryFieldWire.REPEATED_FIXED64_WIRE => {
                    if (res._repeated_fixed64_offset == null) {
                        res._repeated_fixed64_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._repeated_fixed64_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._repeated_fixed64_offset = offset + length_result.size;
                        res._repeated_fixed64_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._repeated_fixed64_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._repeated_fixed64_last_offset = offset;
                    }
                },
                EveryFieldWire.REPEATED_SFIXED32_WIRE => {
                    if (res._repeated_sfixed32_offset == null) {
                        res._repeated_sfixed32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._repeated_sfixed32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._repeated_sfixed32_offset = offset + length_result.size;
                        res._repeated_sfixed32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._repeated_sfixed32_last_offset.?;
                    } else {
                        const result = try buf.readSFixed32(offset);
                        offset += result.size;
                        res._repeated_sfixed32_last_offset = offset;
                    }
                },
                EveryFieldWire.REPEATED_INT32_WIRE => {
                    if (res._repeated_int32_offset == null) {
                        res._repeated_int32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._repeated_int32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._repeated_int32_offset = offset + length_result.size;
                        res._repeated_int32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._repeated_int32_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._repeated_int32_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFieldInt32(self: *const EveryFieldReader) i32 {
        return self._field_int32;
    }
    pub inline fn getFieldInt64(self: *const EveryFieldReader) i64 {
        return self._field_int64;
    }
    pub inline fn getFieldUint32(self: *const EveryFieldReader) u32 {
        return self._field_uint32;
    }
    pub inline fn getFieldUint64(self: *const EveryFieldReader) u64 {
        return self._field_uint64;
    }
    pub inline fn getFieldSint32(self: *const EveryFieldReader) i32 {
        return self._field_sint32;
    }
    pub inline fn getFieldSint64(self: *const EveryFieldReader) i64 {
        return self._field_sint64;
    }
    pub inline fn getFieldFixed32(self: *const EveryFieldReader) u32 {
        return self._field_fixed32;
    }
    pub inline fn getFieldFixed64(self: *const EveryFieldReader) u64 {
        return self._field_fixed64;
    }
    pub inline fn getFieldSfixed32(self: *const EveryFieldReader) i32 {
        return self._field_sfixed32;
    }
    pub inline fn getFieldSfixed64(self: *const EveryFieldReader) i64 {
        return self._field_sfixed64;
    }
    pub inline fn getFieldFloat(self: *const EveryFieldReader) f32 {
        return self._field_float;
    }
    pub inline fn getFieldDouble(self: *const EveryFieldReader) f64 {
        return self._field_double;
    }
    pub inline fn getFieldBool(self: *const EveryFieldReader) bool {
        return self._field_bool;
    }
    pub fn fieldNestedCount(self: *const EveryFieldReader) usize {
        return self._field_nested_cnt;
    }
    pub fn fieldNestedNext(self: *EveryFieldReader) ?EveryFieldReader {
        if (self._field_nested_offset == null) return null;
        const current_offset = self._field_nested_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = EveryFieldReader.init(result.value) catch return null;
        if (self._field_nested_last_offset != null and current_offset >= self._field_nested_last_offset.?) {
            self._field_nested_offset = null;
            return msg;
        }
        if (self._field_nested_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._field_nested_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EveryFieldWire.FIELD_NESTED_WIRE) {
                self._field_nested_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._field_nested_offset = null;
        return msg;
    }
    pub inline fn getSmallEnum(self: *const EveryFieldReader) SmallEnum {
        return self._small_enum;
    }
    pub inline fn getSignedEnum(self: *const EveryFieldReader) SignedEnum {
        return self._signed_enum;
    }
    pub inline fn getBigEnum(self: *const EveryFieldReader) BigEnum {
        return self._big_enum;
    }
    pub inline fn getVeryNegativeEnum(self: *const EveryFieldReader) VeryNegativeEnum {
        return self._very_negative_enum;
    }
    pub inline fn getFieldString(self: *const EveryFieldReader) []const u8 {
        return self._field_string orelse &[_]u8{};
    }
    pub inline fn getFieldBytes(self: *const EveryFieldReader) []const u8 {
        return self._field_bytes orelse &[_]u8{};
    }
    pub inline fn getNestedEnum(self: *const EveryFieldReader) EveryField.NestedEnum {
        return self._nested_enum;
    }
    pub fn repeatedStringCount(self: *const EveryFieldReader) usize {
        return self._repeated_string_cnt;
    }
    pub fn repeatedStringNext(self: *EveryFieldReader) ?[]const u8 {
        if (self._repeated_string_offset == null) return null;
        const current_offset = self._repeated_string_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._repeated_string_last_offset != null and current_offset >= self._repeated_string_last_offset.?) {
            self._repeated_string_offset = null;
            return result.value;
        }
        if (self._repeated_string_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._repeated_string_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == EveryFieldWire.REPEATED_STRING_WIRE) {
                self._repeated_string_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._repeated_string_offset = null;
        return result.value;
    }
    pub fn repeatedFixed64Next(self: *EveryFieldReader) gremlin.Error!?u64 {
        if (self._repeated_fixed64_offset == null) return null;
        const current_offset = self._repeated_fixed64_offset.?;
        if (current_offset >= self._repeated_fixed64_last_offset.?) {
            self._repeated_fixed64_offset = null;
            return null;
        }
        if (self._repeated_fixed64_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._repeated_fixed64_offset = current_offset + value_result.size;
            if (self._repeated_fixed64_offset.? >= self._repeated_fixed64_last_offset.?) {
                self._repeated_fixed64_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._repeated_fixed64_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == EveryFieldWire.REPEATED_FIXED64_WIRE) {
                    self._repeated_fixed64_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._repeated_fixed64_offset = null;
            return value_result.value;
        }
    }
    pub fn repeatedSfixed32Next(self: *EveryFieldReader) gremlin.Error!?i32 {
        if (self._repeated_sfixed32_offset == null) return null;
        const current_offset = self._repeated_sfixed32_offset.?;
        if (current_offset >= self._repeated_sfixed32_last_offset.?) {
            self._repeated_sfixed32_offset = null;
            return null;
        }
        if (self._repeated_sfixed32_packed) {
            const value_result = try self.buf.readSFixed32(current_offset);
            self._repeated_sfixed32_offset = current_offset + value_result.size;
            if (self._repeated_sfixed32_offset.? >= self._repeated_sfixed32_last_offset.?) {
                self._repeated_sfixed32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readSFixed32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._repeated_sfixed32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == EveryFieldWire.REPEATED_SFIXED32_WIRE) {
                    self._repeated_sfixed32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._repeated_sfixed32_offset = null;
            return value_result.value;
        }
    }
    pub fn repeatedInt32Next(self: *EveryFieldReader) gremlin.Error!?i32 {
        if (self._repeated_int32_offset == null) return null;
        const current_offset = self._repeated_int32_offset.?;
        if (current_offset >= self._repeated_int32_last_offset.?) {
            self._repeated_int32_offset = null;
            return null;
        }
        if (self._repeated_int32_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._repeated_int32_offset = current_offset + value_result.size;
            if (self._repeated_int32_offset.? >= self._repeated_int32_last_offset.?) {
                self._repeated_int32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._repeated_int32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == EveryFieldWire.REPEATED_INT32_WIRE) {
                    self._repeated_int32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._repeated_int32_offset = null;
            return value_result.value;
        }
    }
};
const NestedAWire = struct {
    const REPEATED_A_WIRE: gremlin.ProtoWireNumber = 2;
    const SUPER_NESTED_WIRE: gremlin.ProtoWireNumber = 3;
};
pub const NestedA = struct {
    // nested structs
    const NestedBWire = struct {
        const VALUE_B_WIRE: gremlin.ProtoWireNumber = 1;
    };
    pub const NestedB = struct {
        // nested structs
        const NestedCWire = struct {
            const VALUE_C_WIRE: gremlin.ProtoWireNumber = 1;
        };
        pub const NestedC = struct {
            // fields
            value_c: i32 = 0,
            pub fn calcProtobufSize(self: *const NestedA.NestedB.NestedC) usize {
                var res: usize = 0;
                if (self.value_c != 0) {
                    res += gremlin.sizes.sizeWireNumber(NestedA.NestedB.NestedCWire.VALUE_C_WIRE) + gremlin.sizes.sizeI32(self.value_c);
                }
                return res;
            }
            pub fn encode(self: *const NestedA.NestedB.NestedC, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
                const size = self.calcProtobufSize();
                if (size == 0) {
                    return &[_]u8{};
                }
                const buf = try allocator.alloc(u8, self.calcProtobufSize());
                var writer = gremlin.Writer.init(buf);
                self.encodeTo(&writer);
                return buf;
            }
            pub fn encodeTo(self: *const NestedA.NestedB.NestedC, target: *gremlin.Writer) void {
                if (self.value_c != 0) {
                    target.appendInt32(NestedA.NestedB.NestedCWire.VALUE_C_WIRE, self.value_c);
                }
            }
        };
        pub const NestedCReader = struct {
            buf: gremlin.Reader,
            _value_c: i32 = 0,
            pub fn init(src: []const u8) gremlin.Error!NestedA.NestedB.NestedCReader {
                const buf = gremlin.Reader.init(src);
                var res = NestedA.NestedB.NestedCReader{ .buf = buf };
                if (buf.buf.len == 0) {
                    return res;
                }
                var offset: usize = 0;
                while (buf.hasNext(offset, 0)) {
                    const tag = try buf.readTagAt(offset);
                    offset += tag.size;
                    switch (tag.number) {
                        NestedA.NestedB.NestedCWire.VALUE_C_WIRE => {
                            const result = try buf.readInt32(offset);
                            offset += result.size;
                            res._value_c = result.value;
                        },
                        else => {
                            offset = try buf.skipData(offset, tag.wire);
                        },
                    }
                }
                return res;
            }
            pub fn sourceBytes(self: *const @This()) []const u8 {
                return self.buf.buf;
            }
            pub inline fn getValueC(self: *const NestedA.NestedB.NestedCReader) i32 {
                return self._value_c;
            }
        };
        // fields
        value_b: ?NestedA.NestedB.NestedC = null,
        pub fn calcProtobufSize(self: *const NestedA.NestedB) usize {
            var res: usize = 0;
            if (self.value_b) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    res += gremlin.sizes.sizeWireNumber(NestedA.NestedBWire.VALUE_B_WIRE) + gremlin.sizes.sizeUsize(size) + size;
                }
            }
            return res;
        }
        pub fn encode(self: *const NestedA.NestedB, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const NestedA.NestedB, target: *gremlin.Writer) void {
            if (self.value_b) |v| {
                const size = v.calcProtobufSize();
                if (size > 0) {
                    target.appendBytesTag(NestedA.NestedBWire.VALUE_B_WIRE, size);
                    v.encodeTo(target);
                }
            }
        }
    };
    pub const NestedBReader = struct {
        buf: gremlin.Reader,
        _value_b_buf: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!NestedA.NestedBReader {
            const buf = gremlin.Reader.init(src);
            var res = NestedA.NestedBReader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    NestedA.NestedBWire.VALUE_B_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._value_b_buf = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub fn getValueB(self: *const NestedA.NestedBReader) gremlin.Error!NestedA.NestedB.NestedCReader {
            if (self._value_b_buf) |buf| {
                return try NestedA.NestedB.NestedCReader.init(buf);
            }
            return try NestedA.NestedB.NestedCReader.init(&[_]u8{});
        }
    };
    // fields
    repeated_a: ?[]const ?NestedA.NestedB = null,
    super_nested: ?NestedA.NestedB.NestedC = null,
    pub fn calcProtobufSize(self: *const NestedA) usize {
        var res: usize = 0;
        if (self.repeated_a) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(NestedAWire.REPEATED_A_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.super_nested) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(NestedAWire.SUPER_NESTED_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const NestedA, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const NestedA, target: *gremlin.Writer) void {
        if (self.repeated_a) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(NestedAWire.REPEATED_A_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(NestedAWire.REPEATED_A_WIRE, 0);
                }
            }
        }
        if (self.super_nested) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(NestedAWire.SUPER_NESTED_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const NestedAReader = struct {
    buf: gremlin.Reader,
    _repeated_a_offset: ?usize = null,
    _repeated_a_last_offset: ?usize = null,
    _repeated_a_cnt: usize = 0,
    _super_nested_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!NestedAReader {
        const buf = gremlin.Reader.init(src);
        var res = NestedAReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                NestedAWire.REPEATED_A_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._repeated_a_offset == null) {
                        res._repeated_a_offset = offset - result.size;
                    }
                    res._repeated_a_last_offset = offset;
                    res._repeated_a_cnt += 1;
                },
                NestedAWire.SUPER_NESTED_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._super_nested_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn repeatedACount(self: *const NestedAReader) usize {
        return self._repeated_a_cnt;
    }
    pub fn repeatedANext(self: *NestedAReader) ?NestedA.NestedBReader {
        if (self._repeated_a_offset == null) return null;
        const current_offset = self._repeated_a_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = NestedA.NestedBReader.init(result.value) catch return null;
        if (self._repeated_a_last_offset != null and current_offset >= self._repeated_a_last_offset.?) {
            self._repeated_a_offset = null;
            return msg;
        }
        if (self._repeated_a_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._repeated_a_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == NestedAWire.REPEATED_A_WIRE) {
                self._repeated_a_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._repeated_a_offset = null;
        return msg;
    }
    pub fn getSuperNested(self: *const NestedAReader) gremlin.Error!NestedA.NestedB.NestedCReader {
        if (self._super_nested_buf) |buf| {
            return try NestedA.NestedB.NestedCReader.init(buf);
        }
        return try NestedA.NestedB.NestedCReader.init(&[_]u8{});
    }
};
const CamelCaseFieldsWire = struct {
    const FOO_BAR_BAZ_WIRE: gremlin.ProtoWireNumber = 1;
    const BAR_BAZ_WIRE: gremlin.ProtoWireNumber = 2;
    const MOO_MOO_WIRE: gremlin.ProtoWireNumber = 3;
    const URLENCODER_WIRE: gremlin.ProtoWireNumber = 4;
    const XMAP_WIRE: gremlin.ProtoWireNumber = 5;
    const UR_LE_NCO_DER_WIRE: gremlin.ProtoWireNumber = 6;
    const _BIG_BANG_WIRE: gremlin.ProtoWireNumber = 7;
    const U2_WIRE: gremlin.ProtoWireNumber = 8;
    const BANG_BIG_WIRE: gremlin.ProtoWireNumber = 9;
};
pub const CamelCaseFields = struct {
    // fields
    foo_bar_baz: bool = false,
    bar_baz: bool = false,
    moo_moo: bool = false,
    u_r_l_encoder: bool = false,
    x_map: bool = false,
    ur_l_e_nco_der: bool = false,
    _big_bang: bool = false,
    u2: bool = false,
    bang_big_: bool = false,
    pub fn calcProtobufSize(self: *const CamelCaseFields) usize {
        var res: usize = 0;
        if (self.foo_bar_baz != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.FOO_BAR_BAZ_WIRE) + gremlin.sizes.sizeBool(self.foo_bar_baz);
        }
        if (self.bar_baz != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.BAR_BAZ_WIRE) + gremlin.sizes.sizeBool(self.bar_baz);
        }
        if (self.moo_moo != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.MOO_MOO_WIRE) + gremlin.sizes.sizeBool(self.moo_moo);
        }
        if (self.u_r_l_encoder != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.URLENCODER_WIRE) + gremlin.sizes.sizeBool(self.u_r_l_encoder);
        }
        if (self.x_map != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.XMAP_WIRE) + gremlin.sizes.sizeBool(self.x_map);
        }
        if (self.ur_l_e_nco_der != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.UR_LE_NCO_DER_WIRE) + gremlin.sizes.sizeBool(self.ur_l_e_nco_der);
        }
        if (self._big_bang != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire._BIG_BANG_WIRE) + gremlin.sizes.sizeBool(self._big_bang);
        }
        if (self.u2 != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.U2_WIRE) + gremlin.sizes.sizeBool(self.u2);
        }
        if (self.bang_big_ != false) {
            res += gremlin.sizes.sizeWireNumber(CamelCaseFieldsWire.BANG_BIG_WIRE) + gremlin.sizes.sizeBool(self.bang_big_);
        }
        return res;
    }
    pub fn encode(self: *const CamelCaseFields, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const CamelCaseFields, target: *gremlin.Writer) void {
        if (self.foo_bar_baz != false) {
            target.appendBool(CamelCaseFieldsWire.FOO_BAR_BAZ_WIRE, self.foo_bar_baz);
        }
        if (self.bar_baz != false) {
            target.appendBool(CamelCaseFieldsWire.BAR_BAZ_WIRE, self.bar_baz);
        }
        if (self.moo_moo != false) {
            target.appendBool(CamelCaseFieldsWire.MOO_MOO_WIRE, self.moo_moo);
        }
        if (self.u_r_l_encoder != false) {
            target.appendBool(CamelCaseFieldsWire.URLENCODER_WIRE, self.u_r_l_encoder);
        }
        if (self.x_map != false) {
            target.appendBool(CamelCaseFieldsWire.XMAP_WIRE, self.x_map);
        }
        if (self.ur_l_e_nco_der != false) {
            target.appendBool(CamelCaseFieldsWire.UR_LE_NCO_DER_WIRE, self.ur_l_e_nco_der);
        }
        if (self._big_bang != false) {
            target.appendBool(CamelCaseFieldsWire._BIG_BANG_WIRE, self._big_bang);
        }
        if (self.u2 != false) {
            target.appendBool(CamelCaseFieldsWire.U2_WIRE, self.u2);
        }
        if (self.bang_big_ != false) {
            target.appendBool(CamelCaseFieldsWire.BANG_BIG_WIRE, self.bang_big_);
        }
    }
};
pub const CamelCaseFieldsReader = struct {
    buf: gremlin.Reader,
    _foo_bar_baz: bool = false,
    _bar_baz: bool = false,
    _moo_moo: bool = false,
    _u_r_l_encoder: bool = false,
    _x_map: bool = false,
    _ur_l_e_nco_der: bool = false,
    __big_bang: bool = false,
    _u2: bool = false,
    _bang_big_: bool = false,
    pub fn init(src: []const u8) gremlin.Error!CamelCaseFieldsReader {
        const buf = gremlin.Reader.init(src);
        var res = CamelCaseFieldsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                CamelCaseFieldsWire.FOO_BAR_BAZ_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._foo_bar_baz = result.value;
                },
                CamelCaseFieldsWire.BAR_BAZ_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._bar_baz = result.value;
                },
                CamelCaseFieldsWire.MOO_MOO_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._moo_moo = result.value;
                },
                CamelCaseFieldsWire.URLENCODER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._u_r_l_encoder = result.value;
                },
                CamelCaseFieldsWire.XMAP_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._x_map = result.value;
                },
                CamelCaseFieldsWire.UR_LE_NCO_DER_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._ur_l_e_nco_der = result.value;
                },
                CamelCaseFieldsWire._BIG_BANG_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res.__big_bang = result.value;
                },
                CamelCaseFieldsWire.U2_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._u2 = result.value;
                },
                CamelCaseFieldsWire.BANG_BIG_WIRE => {
                    const result = try buf.readBool(offset);
                    offset += result.size;
                    res._bang_big_ = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getFooBarBaz(self: *const CamelCaseFieldsReader) bool {
        return self._foo_bar_baz;
    }
    pub inline fn getBarBaz(self: *const CamelCaseFieldsReader) bool {
        return self._bar_baz;
    }
    pub inline fn getMooMoo(self: *const CamelCaseFieldsReader) bool {
        return self._moo_moo;
    }
    pub inline fn getURLEncoder(self: *const CamelCaseFieldsReader) bool {
        return self._u_r_l_encoder;
    }
    pub inline fn getXMap(self: *const CamelCaseFieldsReader) bool {
        return self._x_map;
    }
    pub inline fn getUrLENcoDer(self: *const CamelCaseFieldsReader) bool {
        return self._ur_l_e_nco_der;
    }
    pub inline fn getBigBang(self: *const CamelCaseFieldsReader) bool {
        return self.__big_bang;
    }
    pub inline fn getU2(self: *const CamelCaseFieldsReader) bool {
        return self._u2;
    }
    pub inline fn getBangBig(self: *const CamelCaseFieldsReader) bool {
        return self._bang_big_;
    }
};
const PackedRepeatedFieldsWire = struct {
    const FIELD_INT32_WIRE: gremlin.ProtoWireNumber = 1;
    const FIELD_INT64_WIRE: gremlin.ProtoWireNumber = 4;
    const FIELD_UINT32_WIRE: gremlin.ProtoWireNumber = 5;
    const FIELD_UINT64_WIRE: gremlin.ProtoWireNumber = 6;
    const FIELD_FIXED32_WIRE: gremlin.ProtoWireNumber = 2;
    const FIELD_FIXED64_WIRE: gremlin.ProtoWireNumber = 9;
    const FIELD_SFIXED32_WIRE: gremlin.ProtoWireNumber = 10;
    const FIELD_SFIXED64_WIRE: gremlin.ProtoWireNumber = 3;
    const FIELD_FLOAT_WIRE: gremlin.ProtoWireNumber = 11;
    const FIELD_DOUBLE_WIRE: gremlin.ProtoWireNumber = 12;
    const SMALL_ENUM_WIRE: gremlin.ProtoWireNumber = 51;
    const SIGNED_ENUM_WIRE: gremlin.ProtoWireNumber = 52;
    const BIG_ENUM_WIRE: gremlin.ProtoWireNumber = 53;
};
pub const PackedRepeatedFields = struct {
    // fields
    field_int32: ?[]const i32 = null,
    field_int64: ?[]const i64 = null,
    field_uint32: ?[]const u32 = null,
    field_uint64: ?[]const u64 = null,
    field_fixed32: ?[]const u32 = null,
    field_fixed64: ?[]const u64 = null,
    field_sfixed32: ?[]const i32 = null,
    field_sfixed64: ?[]const i64 = null,
    field_float: ?[]const f32 = null,
    field_double: ?[]const f64 = null,
    small_enum: ?[]const SmallEnum = null,
    signed_enum: ?[]const SignedEnum = null,
    big_enum: ?[]const BigEnum = null,
    pub fn calcProtobufSize(self: *const PackedRepeatedFields) usize {
        var res: usize = 0;
        if (self.field_int32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_INT32_WIRE) + gremlin.sizes.sizeI32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_INT32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_int64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_INT64_WIRE) + gremlin.sizes.sizeI64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_INT64_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_uint32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_UINT32_WIRE) + gremlin.sizes.sizeU32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_UINT32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_uint64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_UINT64_WIRE) + gremlin.sizes.sizeU64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_UINT64_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_fixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE) + gremlin.sizes.sizeFixed32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_fixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE) + gremlin.sizes.sizeFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_sfixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE) + gremlin.sizes.sizeSFixed32(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed32(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_sfixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE) + gremlin.sizes.sizeSFixed64(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed64(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_float) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE) + gremlin.sizes.sizeFloat(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.field_double) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE) + gremlin.sizes.sizeDouble(arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.small_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.SMALL_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.SMALL_ENUM_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.signed_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.big_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.BIG_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(PackedRepeatedFieldsWire.BIG_ENUM_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        return res;
    }
    pub fn encode(self: *const PackedRepeatedFields, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const PackedRepeatedFields, target: *gremlin.Writer) void {
        if (self.field_int32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PackedRepeatedFieldsWire.FIELD_INT32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_INT32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(v);
                }
            }
        }
        if (self.field_int64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt64(PackedRepeatedFieldsWire.FIELD_INT64_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI64(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_INT64_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt64WithoutTag(v);
                }
            }
        }
        if (self.field_uint32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint32(PackedRepeatedFieldsWire.FIELD_UINT32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU32(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_UINT32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint32WithoutTag(v);
                }
            }
        }
        if (self.field_uint64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendUint64(PackedRepeatedFieldsWire.FIELD_UINT64_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeU64(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_UINT64_WIRE, packed_size);
                for (arr) |v| {
                    target.appendUint64WithoutTag(v);
                }
            }
        }
        if (self.field_fixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed32(PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed32(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed32WithoutTag(v);
                }
            }
        }
        if (self.field_fixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFixed64(PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFixed64(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFixed64WithoutTag(v);
                }
            }
        }
        if (self.field_sfixed32) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendSfixed32(PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed32(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE, packed_size);
                for (arr) |v| {
                    target.appendSfixed32WithoutTag(v);
                }
            }
        }
        if (self.field_sfixed64) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendSfixed64(PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeSFixed64(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE, packed_size);
                for (arr) |v| {
                    target.appendSfixed64WithoutTag(v);
                }
            }
        }
        if (self.field_float) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat32(PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeFloat(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat32WithoutTag(v);
                }
            }
        }
        if (self.field_double) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendFloat64(PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE, arr[0]);
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeDouble(v);
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE, packed_size);
                for (arr) |v| {
                    target.appendFloat64WithoutTag(v);
                }
            }
        }
        if (self.small_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PackedRepeatedFieldsWire.SMALL_ENUM_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.SMALL_ENUM_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.signed_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.big_enum) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(PackedRepeatedFieldsWire.BIG_ENUM_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(PackedRepeatedFieldsWire.BIG_ENUM_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
    }
};
pub const PackedRepeatedFieldsReader = struct {
    buf: gremlin.Reader,
    _field_int32_offset: ?usize = null,
    _field_int32_last_offset: ?usize = null,
    _field_int32_packed: bool = false,
    _field_int64_offset: ?usize = null,
    _field_int64_last_offset: ?usize = null,
    _field_int64_packed: bool = false,
    _field_uint32_offset: ?usize = null,
    _field_uint32_last_offset: ?usize = null,
    _field_uint32_packed: bool = false,
    _field_uint64_offset: ?usize = null,
    _field_uint64_last_offset: ?usize = null,
    _field_uint64_packed: bool = false,
    _field_fixed32_offset: ?usize = null,
    _field_fixed32_last_offset: ?usize = null,
    _field_fixed32_packed: bool = false,
    _field_fixed64_offset: ?usize = null,
    _field_fixed64_last_offset: ?usize = null,
    _field_fixed64_packed: bool = false,
    _field_sfixed32_offset: ?usize = null,
    _field_sfixed32_last_offset: ?usize = null,
    _field_sfixed32_packed: bool = false,
    _field_sfixed64_offset: ?usize = null,
    _field_sfixed64_last_offset: ?usize = null,
    _field_sfixed64_packed: bool = false,
    _field_float_offset: ?usize = null,
    _field_float_last_offset: ?usize = null,
    _field_float_packed: bool = false,
    _field_double_offset: ?usize = null,
    _field_double_last_offset: ?usize = null,
    _field_double_packed: bool = false,
    _small_enum_offset: ?usize = null,
    _small_enum_last_offset: ?usize = null,
    _small_enum_packed: bool = false,
    _signed_enum_offset: ?usize = null,
    _signed_enum_last_offset: ?usize = null,
    _signed_enum_packed: bool = false,
    _big_enum_offset: ?usize = null,
    _big_enum_last_offset: ?usize = null,
    _big_enum_packed: bool = false,
    pub fn init(src: []const u8) gremlin.Error!PackedRepeatedFieldsReader {
        const buf = gremlin.Reader.init(src);
        var res = PackedRepeatedFieldsReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                PackedRepeatedFieldsWire.FIELD_INT32_WIRE => {
                    if (res._field_int32_offset == null) {
                        res._field_int32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_int32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_int32_offset = offset + length_result.size;
                        res._field_int32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_int32_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._field_int32_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_INT64_WIRE => {
                    if (res._field_int64_offset == null) {
                        res._field_int64_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_int64_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_int64_offset = offset + length_result.size;
                        res._field_int64_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_int64_last_offset.?;
                    } else {
                        const result = try buf.readInt64(offset);
                        offset += result.size;
                        res._field_int64_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_UINT32_WIRE => {
                    if (res._field_uint32_offset == null) {
                        res._field_uint32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_uint32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_uint32_offset = offset + length_result.size;
                        res._field_uint32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_uint32_last_offset.?;
                    } else {
                        const result = try buf.readUInt32(offset);
                        offset += result.size;
                        res._field_uint32_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_UINT64_WIRE => {
                    if (res._field_uint64_offset == null) {
                        res._field_uint64_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_uint64_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_uint64_offset = offset + length_result.size;
                        res._field_uint64_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_uint64_last_offset.?;
                    } else {
                        const result = try buf.readUInt64(offset);
                        offset += result.size;
                        res._field_uint64_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE => {
                    if (res._field_fixed32_offset == null) {
                        res._field_fixed32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_fixed32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_fixed32_offset = offset + length_result.size;
                        res._field_fixed32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_fixed32_last_offset.?;
                    } else {
                        const result = try buf.readFixed32(offset);
                        offset += result.size;
                        res._field_fixed32_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE => {
                    if (res._field_fixed64_offset == null) {
                        res._field_fixed64_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_fixed64_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_fixed64_offset = offset + length_result.size;
                        res._field_fixed64_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_fixed64_last_offset.?;
                    } else {
                        const result = try buf.readFixed64(offset);
                        offset += result.size;
                        res._field_fixed64_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE => {
                    if (res._field_sfixed32_offset == null) {
                        res._field_sfixed32_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_sfixed32_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_sfixed32_offset = offset + length_result.size;
                        res._field_sfixed32_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_sfixed32_last_offset.?;
                    } else {
                        const result = try buf.readSFixed32(offset);
                        offset += result.size;
                        res._field_sfixed32_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE => {
                    if (res._field_sfixed64_offset == null) {
                        res._field_sfixed64_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_sfixed64_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_sfixed64_offset = offset + length_result.size;
                        res._field_sfixed64_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_sfixed64_last_offset.?;
                    } else {
                        const result = try buf.readSFixed64(offset);
                        offset += result.size;
                        res._field_sfixed64_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE => {
                    if (res._field_float_offset == null) {
                        res._field_float_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_float_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_float_offset = offset + length_result.size;
                        res._field_float_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_float_last_offset.?;
                    } else {
                        const result = try buf.readFloat32(offset);
                        offset += result.size;
                        res._field_float_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE => {
                    if (res._field_double_offset == null) {
                        res._field_double_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._field_double_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._field_double_offset = offset + length_result.size;
                        res._field_double_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._field_double_last_offset.?;
                    } else {
                        const result = try buf.readFloat64(offset);
                        offset += result.size;
                        res._field_double_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.SMALL_ENUM_WIRE => {
                    if (res._small_enum_offset == null) {
                        res._small_enum_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._small_enum_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._small_enum_offset = offset + length_result.size;
                        res._small_enum_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._small_enum_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._small_enum_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE => {
                    if (res._signed_enum_offset == null) {
                        res._signed_enum_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._signed_enum_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._signed_enum_offset = offset + length_result.size;
                        res._signed_enum_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._signed_enum_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._signed_enum_last_offset = offset;
                    }
                },
                PackedRepeatedFieldsWire.BIG_ENUM_WIRE => {
                    if (res._big_enum_offset == null) {
                        res._big_enum_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._big_enum_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._big_enum_offset = offset + length_result.size;
                        res._big_enum_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._big_enum_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._big_enum_last_offset = offset;
                    }
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn fieldInt32Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?i32 {
        if (self._field_int32_offset == null) return null;
        const current_offset = self._field_int32_offset.?;
        if (current_offset >= self._field_int32_last_offset.?) {
            self._field_int32_offset = null;
            return null;
        }
        if (self._field_int32_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._field_int32_offset = current_offset + value_result.size;
            if (self._field_int32_offset.? >= self._field_int32_last_offset.?) {
                self._field_int32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_int32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_INT32_WIRE) {
                    self._field_int32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_int32_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldInt64Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?i64 {
        if (self._field_int64_offset == null) return null;
        const current_offset = self._field_int64_offset.?;
        if (current_offset >= self._field_int64_last_offset.?) {
            self._field_int64_offset = null;
            return null;
        }
        if (self._field_int64_packed) {
            const value_result = try self.buf.readInt64(current_offset);
            self._field_int64_offset = current_offset + value_result.size;
            if (self._field_int64_offset.? >= self._field_int64_last_offset.?) {
                self._field_int64_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_int64_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_INT64_WIRE) {
                    self._field_int64_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_int64_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldUint32Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?u32 {
        if (self._field_uint32_offset == null) return null;
        const current_offset = self._field_uint32_offset.?;
        if (current_offset >= self._field_uint32_last_offset.?) {
            self._field_uint32_offset = null;
            return null;
        }
        if (self._field_uint32_packed) {
            const value_result = try self.buf.readUInt32(current_offset);
            self._field_uint32_offset = current_offset + value_result.size;
            if (self._field_uint32_offset.? >= self._field_uint32_last_offset.?) {
                self._field_uint32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_uint32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_UINT32_WIRE) {
                    self._field_uint32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_uint32_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldUint64Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?u64 {
        if (self._field_uint64_offset == null) return null;
        const current_offset = self._field_uint64_offset.?;
        if (current_offset >= self._field_uint64_last_offset.?) {
            self._field_uint64_offset = null;
            return null;
        }
        if (self._field_uint64_packed) {
            const value_result = try self.buf.readUInt64(current_offset);
            self._field_uint64_offset = current_offset + value_result.size;
            if (self._field_uint64_offset.? >= self._field_uint64_last_offset.?) {
                self._field_uint64_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readUInt64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_uint64_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_UINT64_WIRE) {
                    self._field_uint64_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_uint64_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldFixed32Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?u32 {
        if (self._field_fixed32_offset == null) return null;
        const current_offset = self._field_fixed32_offset.?;
        if (current_offset >= self._field_fixed32_last_offset.?) {
            self._field_fixed32_offset = null;
            return null;
        }
        if (self._field_fixed32_packed) {
            const value_result = try self.buf.readFixed32(current_offset);
            self._field_fixed32_offset = current_offset + value_result.size;
            if (self._field_fixed32_offset.? >= self._field_fixed32_last_offset.?) {
                self._field_fixed32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_fixed32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_FIXED32_WIRE) {
                    self._field_fixed32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_fixed32_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldFixed64Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?u64 {
        if (self._field_fixed64_offset == null) return null;
        const current_offset = self._field_fixed64_offset.?;
        if (current_offset >= self._field_fixed64_last_offset.?) {
            self._field_fixed64_offset = null;
            return null;
        }
        if (self._field_fixed64_packed) {
            const value_result = try self.buf.readFixed64(current_offset);
            self._field_fixed64_offset = current_offset + value_result.size;
            if (self._field_fixed64_offset.? >= self._field_fixed64_last_offset.?) {
                self._field_fixed64_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_fixed64_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_FIXED64_WIRE) {
                    self._field_fixed64_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_fixed64_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldSfixed32Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?i32 {
        if (self._field_sfixed32_offset == null) return null;
        const current_offset = self._field_sfixed32_offset.?;
        if (current_offset >= self._field_sfixed32_last_offset.?) {
            self._field_sfixed32_offset = null;
            return null;
        }
        if (self._field_sfixed32_packed) {
            const value_result = try self.buf.readSFixed32(current_offset);
            self._field_sfixed32_offset = current_offset + value_result.size;
            if (self._field_sfixed32_offset.? >= self._field_sfixed32_last_offset.?) {
                self._field_sfixed32_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readSFixed32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_sfixed32_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_SFIXED32_WIRE) {
                    self._field_sfixed32_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_sfixed32_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldSfixed64Next(self: *PackedRepeatedFieldsReader) gremlin.Error!?i64 {
        if (self._field_sfixed64_offset == null) return null;
        const current_offset = self._field_sfixed64_offset.?;
        if (current_offset >= self._field_sfixed64_last_offset.?) {
            self._field_sfixed64_offset = null;
            return null;
        }
        if (self._field_sfixed64_packed) {
            const value_result = try self.buf.readSFixed64(current_offset);
            self._field_sfixed64_offset = current_offset + value_result.size;
            if (self._field_sfixed64_offset.? >= self._field_sfixed64_last_offset.?) {
                self._field_sfixed64_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readSFixed64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_sfixed64_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_SFIXED64_WIRE) {
                    self._field_sfixed64_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_sfixed64_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldFloatNext(self: *PackedRepeatedFieldsReader) gremlin.Error!?f32 {
        if (self._field_float_offset == null) return null;
        const current_offset = self._field_float_offset.?;
        if (current_offset >= self._field_float_last_offset.?) {
            self._field_float_offset = null;
            return null;
        }
        if (self._field_float_packed) {
            const value_result = try self.buf.readFloat32(current_offset);
            self._field_float_offset = current_offset + value_result.size;
            if (self._field_float_offset.? >= self._field_float_last_offset.?) {
                self._field_float_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_float_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_FLOAT_WIRE) {
                    self._field_float_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_float_offset = null;
            return value_result.value;
        }
    }
    pub fn fieldDoubleNext(self: *PackedRepeatedFieldsReader) gremlin.Error!?f64 {
        if (self._field_double_offset == null) return null;
        const current_offset = self._field_double_offset.?;
        if (current_offset >= self._field_double_last_offset.?) {
            self._field_double_offset = null;
            return null;
        }
        if (self._field_double_packed) {
            const value_result = try self.buf.readFloat64(current_offset);
            self._field_double_offset = current_offset + value_result.size;
            if (self._field_double_offset.? >= self._field_double_last_offset.?) {
                self._field_double_offset = null;
            }
            return value_result.value;
        } else {
            const value_result = try self.buf.readFloat64(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._field_double_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.FIELD_DOUBLE_WIRE) {
                    self._field_double_offset = next_offset;
                    return value_result.value;
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._field_double_offset = null;
            return value_result.value;
        }
    }
    pub fn smallEnumNext(self: *PackedRepeatedFieldsReader) gremlin.Error!?SmallEnum {
        if (self._small_enum_offset == null) return null;
        const current_offset = self._small_enum_offset.?;
        if (current_offset >= self._small_enum_last_offset.?) {
            self._small_enum_offset = null;
            return null;
        }
        if (self._small_enum_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._small_enum_offset = current_offset + value_result.size;
            if (self._small_enum_offset.? >= self._small_enum_last_offset.?) {
                self._small_enum_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._small_enum_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.SMALL_ENUM_WIRE) {
                    self._small_enum_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._small_enum_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub fn signedEnumNext(self: *PackedRepeatedFieldsReader) gremlin.Error!?SignedEnum {
        if (self._signed_enum_offset == null) return null;
        const current_offset = self._signed_enum_offset.?;
        if (current_offset >= self._signed_enum_last_offset.?) {
            self._signed_enum_offset = null;
            return null;
        }
        if (self._signed_enum_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._signed_enum_offset = current_offset + value_result.size;
            if (self._signed_enum_offset.? >= self._signed_enum_last_offset.?) {
                self._signed_enum_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._signed_enum_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.SIGNED_ENUM_WIRE) {
                    self._signed_enum_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._signed_enum_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub fn bigEnumNext(self: *PackedRepeatedFieldsReader) gremlin.Error!?BigEnum {
        if (self._big_enum_offset == null) return null;
        const current_offset = self._big_enum_offset.?;
        if (current_offset >= self._big_enum_last_offset.?) {
            self._big_enum_offset = null;
            return null;
        }
        if (self._big_enum_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._big_enum_offset = current_offset + value_result.size;
            if (self._big_enum_offset.? >= self._big_enum_last_offset.?) {
                self._big_enum_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._big_enum_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == PackedRepeatedFieldsWire.BIG_ENUM_WIRE) {
                    self._big_enum_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._big_enum_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
};
const TestVersioningV1Wire = struct {
    const ROOT_INT_WIRE: gremlin.ProtoWireNumber = 1;
    const ENUMZ_WIRE: gremlin.ProtoWireNumber = 2;
    const ROOT_STRING_WIRE: gremlin.ProtoWireNumber = 3;
    const REP_STRING_WIRE: gremlin.ProtoWireNumber = 4;
    const SUB1_WIRE: gremlin.ProtoWireNumber = 5;
    const SUB1_REP_WIRE: gremlin.ProtoWireNumber = 6;
    const SUB1_LAZY_WIRE: gremlin.ProtoWireNumber = 7;
};
pub const TestVersioningV1 = struct {
    // nested enums
    pub const EnumzV1 = enum(i32) {
        ONE = 1,
        TWO = 2,
        _PROTOBUF_UNKNOWN = 0,
    };
    // nested structs
    const Sub1V1Wire = struct {
        const SUB1_INT_WIRE: gremlin.ProtoWireNumber = 1;
        const SUB1_STRING_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Sub1V1 = struct {
        // fields
        sub1_int: i32 = 0,
        sub1_string: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TestVersioningV1.Sub1V1) usize {
            var res: usize = 0;
            if (self.sub1_int != 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1.Sub1V1Wire.SUB1_INT_WIRE) + gremlin.sizes.sizeI32(self.sub1_int);
            }
            if (self.sub1_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestVersioningV1.Sub1V1Wire.SUB1_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TestVersioningV1.Sub1V1, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TestVersioningV1.Sub1V1, target: *gremlin.Writer) void {
            if (self.sub1_int != 0) {
                target.appendInt32(TestVersioningV1.Sub1V1Wire.SUB1_INT_WIRE, self.sub1_int);
            }
            if (self.sub1_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestVersioningV1.Sub1V1Wire.SUB1_STRING_WIRE, v);
                }
            }
        }
    };
    pub const Sub1V1Reader = struct {
        buf: gremlin.Reader,
        _sub1_int: i32 = 0,
        _sub1_string: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TestVersioningV1.Sub1V1Reader {
            const buf = gremlin.Reader.init(src);
            var res = TestVersioningV1.Sub1V1Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TestVersioningV1.Sub1V1Wire.SUB1_INT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._sub1_int = result.value;
                    },
                    TestVersioningV1.Sub1V1Wire.SUB1_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sub1_string = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSub1Int(self: *const TestVersioningV1.Sub1V1Reader) i32 {
            return self._sub1_int;
        }
        pub inline fn getSub1String(self: *const TestVersioningV1.Sub1V1Reader) []const u8 {
            return self._sub1_string orelse &[_]u8{};
        }
    };
    // fields
    root_int: i32 = 0,
    enumz: ?[]const TestVersioningV1.EnumzV1 = null,
    root_string: ?[]const u8 = null,
    rep_string: ?[]const ?[]const u8 = null,
    sub1: ?TestVersioningV1.Sub1V1 = null,
    sub1_rep: ?[]const ?TestVersioningV1.Sub1V1 = null,
    sub1_lazy: ?TestVersioningV1.Sub1V1 = null,
    pub fn calcProtobufSize(self: *const TestVersioningV1) usize {
        var res: usize = 0;
        if (self.root_int != 0) {
            res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.ROOT_INT_WIRE) + gremlin.sizes.sizeI32(self.root_int);
        }
        if (self.enumz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.ENUMZ_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.ENUMZ_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.root_string) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.ROOT_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.rep_string) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.REP_STRING_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sub1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.SUB1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sub1_rep) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.SUB1_REP_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sub1_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV1Wire.SUB1_LAZY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TestVersioningV1, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestVersioningV1, target: *gremlin.Writer) void {
        if (self.root_int != 0) {
            target.appendInt32(TestVersioningV1Wire.ROOT_INT_WIRE, self.root_int);
        }
        if (self.enumz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(TestVersioningV1Wire.ENUMZ_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(TestVersioningV1Wire.ENUMZ_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.root_string) |v| {
            if (v.len > 0) {
                target.appendBytes(TestVersioningV1Wire.ROOT_STRING_WIRE, v);
            }
        }
        if (self.rep_string) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TestVersioningV1Wire.REP_STRING_WIRE, v);
                } else {
                    target.appendBytesTag(TestVersioningV1Wire.REP_STRING_WIRE, 0);
                }
            }
        }
        if (self.sub1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV1Wire.SUB1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sub1_rep) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TestVersioningV1Wire.SUB1_REP_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TestVersioningV1Wire.SUB1_REP_WIRE, 0);
                }
            }
        }
        if (self.sub1_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV1Wire.SUB1_LAZY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TestVersioningV1Reader = struct {
    buf: gremlin.Reader,
    _root_int: i32 = 0,
    _enumz_offset: ?usize = null,
    _enumz_last_offset: ?usize = null,
    _enumz_packed: bool = false,
    _root_string: ?[]const u8 = null,
    _rep_string_offset: ?usize = null,
    _rep_string_last_offset: ?usize = null,
    _rep_string_cnt: usize = 0,
    _sub1_buf: ?[]const u8 = null,
    _sub1_rep_offset: ?usize = null,
    _sub1_rep_last_offset: ?usize = null,
    _sub1_rep_cnt: usize = 0,
    _sub1_lazy_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TestVersioningV1Reader {
        const buf = gremlin.Reader.init(src);
        var res = TestVersioningV1Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestVersioningV1Wire.ROOT_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._root_int = result.value;
                },
                TestVersioningV1Wire.ENUMZ_WIRE => {
                    if (res._enumz_offset == null) {
                        res._enumz_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._enumz_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._enumz_offset = offset + length_result.size;
                        res._enumz_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._enumz_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._enumz_last_offset = offset;
                    }
                },
                TestVersioningV1Wire.ROOT_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._root_string = result.value;
                },
                TestVersioningV1Wire.REP_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._rep_string_offset == null) {
                        res._rep_string_offset = offset - result.size;
                    }
                    res._rep_string_last_offset = offset;
                    res._rep_string_cnt += 1;
                },
                TestVersioningV1Wire.SUB1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub1_buf = result.value;
                },
                TestVersioningV1Wire.SUB1_REP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sub1_rep_offset == null) {
                        res._sub1_rep_offset = offset - result.size;
                    }
                    res._sub1_rep_last_offset = offset;
                    res._sub1_rep_cnt += 1;
                },
                TestVersioningV1Wire.SUB1_LAZY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub1_lazy_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRootInt(self: *const TestVersioningV1Reader) i32 {
        return self._root_int;
    }
    pub fn enumzNext(self: *TestVersioningV1Reader) gremlin.Error!?TestVersioningV1.EnumzV1 {
        if (self._enumz_offset == null) return null;
        const current_offset = self._enumz_offset.?;
        if (current_offset >= self._enumz_last_offset.?) {
            self._enumz_offset = null;
            return null;
        }
        if (self._enumz_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._enumz_offset = current_offset + value_result.size;
            if (self._enumz_offset.? >= self._enumz_last_offset.?) {
                self._enumz_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._enumz_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestVersioningV1Wire.ENUMZ_WIRE) {
                    self._enumz_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._enumz_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getRootString(self: *const TestVersioningV1Reader) []const u8 {
        return self._root_string orelse &[_]u8{};
    }
    pub fn repStringCount(self: *const TestVersioningV1Reader) usize {
        return self._rep_string_cnt;
    }
    pub fn repStringNext(self: *TestVersioningV1Reader) ?[]const u8 {
        if (self._rep_string_offset == null) return null;
        const current_offset = self._rep_string_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._rep_string_last_offset != null and current_offset >= self._rep_string_last_offset.?) {
            self._rep_string_offset = null;
            return result.value;
        }
        if (self._rep_string_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._rep_string_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestVersioningV1Wire.REP_STRING_WIRE) {
                self._rep_string_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._rep_string_offset = null;
        return result.value;
    }
    pub fn getSub1(self: *const TestVersioningV1Reader) gremlin.Error!TestVersioningV1.Sub1V1Reader {
        if (self._sub1_buf) |buf| {
            return try TestVersioningV1.Sub1V1Reader.init(buf);
        }
        return try TestVersioningV1.Sub1V1Reader.init(&[_]u8{});
    }
    pub fn sub1RepCount(self: *const TestVersioningV1Reader) usize {
        return self._sub1_rep_cnt;
    }
    pub fn sub1RepNext(self: *TestVersioningV1Reader) ?TestVersioningV1.Sub1V1Reader {
        if (self._sub1_rep_offset == null) return null;
        const current_offset = self._sub1_rep_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TestVersioningV1.Sub1V1Reader.init(result.value) catch return null;
        if (self._sub1_rep_last_offset != null and current_offset >= self._sub1_rep_last_offset.?) {
            self._sub1_rep_offset = null;
            return msg;
        }
        if (self._sub1_rep_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sub1_rep_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestVersioningV1Wire.SUB1_REP_WIRE) {
                self._sub1_rep_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sub1_rep_offset = null;
        return msg;
    }
    pub fn getSub1Lazy(self: *const TestVersioningV1Reader) gremlin.Error!TestVersioningV1.Sub1V1Reader {
        if (self._sub1_lazy_buf) |buf| {
            return try TestVersioningV1.Sub1V1Reader.init(buf);
        }
        return try TestVersioningV1.Sub1V1Reader.init(&[_]u8{});
    }
};
const TestVersioningV2Wire = struct {
    const ROOT_INT_WIRE: gremlin.ProtoWireNumber = 1;
    const ENUMZ_WIRE: gremlin.ProtoWireNumber = 2;
    const ROOT_STRING_WIRE: gremlin.ProtoWireNumber = 3;
    const REP_STRING_WIRE: gremlin.ProtoWireNumber = 4;
    const SUB1_WIRE: gremlin.ProtoWireNumber = 5;
    const SUB1_REP_WIRE: gremlin.ProtoWireNumber = 6;
    const SUB1_LAZY_WIRE: gremlin.ProtoWireNumber = 7;
    const ROOT_INT_V2_WIRE: gremlin.ProtoWireNumber = 10;
    const SUB2_WIRE: gremlin.ProtoWireNumber = 11;
    const SUB2_REP_WIRE: gremlin.ProtoWireNumber = 12;
    const SUB2_LAZY_WIRE: gremlin.ProtoWireNumber = 13;
};
pub const TestVersioningV2 = struct {
    // nested enums
    pub const EnumzV2 = enum(i32) {
        ONE = 1,
        TWO = 2,
        THREE_V2 = 3,
        _PROTOBUF_UNKNOWN = 0,
    };
    // nested structs
    const Sub1V2Wire = struct {
        const SUB1_INT_WIRE: gremlin.ProtoWireNumber = 1;
        const SUB1_STRING_WIRE: gremlin.ProtoWireNumber = 2;
        const SUB1_INT_V2_WIRE: gremlin.ProtoWireNumber = 3;
        const SUB1_STRING_V2_WIRE: gremlin.ProtoWireNumber = 4;
    };
    pub const Sub1V2 = struct {
        // fields
        sub1_int: i32 = 0,
        sub1_string: ?[]const u8 = null,
        sub1_int_v2: i32 = 0,
        sub1_string_v2: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TestVersioningV2.Sub1V2) usize {
            var res: usize = 0;
            if (self.sub1_int != 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub1V2Wire.SUB1_INT_WIRE) + gremlin.sizes.sizeI32(self.sub1_int);
            }
            if (self.sub1_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub1V2Wire.SUB1_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            if (self.sub1_int_v2 != 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub1V2Wire.SUB1_INT_V2_WIRE) + gremlin.sizes.sizeI32(self.sub1_int_v2);
            }
            if (self.sub1_string_v2) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub1V2Wire.SUB1_STRING_V2_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TestVersioningV2.Sub1V2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TestVersioningV2.Sub1V2, target: *gremlin.Writer) void {
            if (self.sub1_int != 0) {
                target.appendInt32(TestVersioningV2.Sub1V2Wire.SUB1_INT_WIRE, self.sub1_int);
            }
            if (self.sub1_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestVersioningV2.Sub1V2Wire.SUB1_STRING_WIRE, v);
                }
            }
            if (self.sub1_int_v2 != 0) {
                target.appendInt32(TestVersioningV2.Sub1V2Wire.SUB1_INT_V2_WIRE, self.sub1_int_v2);
            }
            if (self.sub1_string_v2) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestVersioningV2.Sub1V2Wire.SUB1_STRING_V2_WIRE, v);
                }
            }
        }
    };
    pub const Sub1V2Reader = struct {
        buf: gremlin.Reader,
        _sub1_int: i32 = 0,
        _sub1_string: ?[]const u8 = null,
        _sub1_int_v2: i32 = 0,
        _sub1_string_v2: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TestVersioningV2.Sub1V2Reader {
            const buf = gremlin.Reader.init(src);
            var res = TestVersioningV2.Sub1V2Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TestVersioningV2.Sub1V2Wire.SUB1_INT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._sub1_int = result.value;
                    },
                    TestVersioningV2.Sub1V2Wire.SUB1_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sub1_string = result.value;
                    },
                    TestVersioningV2.Sub1V2Wire.SUB1_INT_V2_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._sub1_int_v2 = result.value;
                    },
                    TestVersioningV2.Sub1V2Wire.SUB1_STRING_V2_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sub1_string_v2 = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSub1Int(self: *const TestVersioningV2.Sub1V2Reader) i32 {
            return self._sub1_int;
        }
        pub inline fn getSub1String(self: *const TestVersioningV2.Sub1V2Reader) []const u8 {
            return self._sub1_string orelse &[_]u8{};
        }
        pub inline fn getSub1IntV2(self: *const TestVersioningV2.Sub1V2Reader) i32 {
            return self._sub1_int_v2;
        }
        pub inline fn getSub1StringV2(self: *const TestVersioningV2.Sub1V2Reader) []const u8 {
            return self._sub1_string_v2 orelse &[_]u8{};
        }
    };
    const Sub2V2Wire = struct {
        const SUB2_INT_WIRE: gremlin.ProtoWireNumber = 1;
        const SUB2_STRING_WIRE: gremlin.ProtoWireNumber = 2;
    };
    pub const Sub2V2 = struct {
        // fields
        sub2_int: i32 = 0,
        sub2_string: ?[]const u8 = null,
        pub fn calcProtobufSize(self: *const TestVersioningV2.Sub2V2) usize {
            var res: usize = 0;
            if (self.sub2_int != 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub2V2Wire.SUB2_INT_WIRE) + gremlin.sizes.sizeI32(self.sub2_int);
            }
            if (self.sub2_string) |v| {
                if (v.len > 0) {
                    res += gremlin.sizes.sizeWireNumber(TestVersioningV2.Sub2V2Wire.SUB2_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
                }
            }
            return res;
        }
        pub fn encode(self: *const TestVersioningV2.Sub2V2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
            const size = self.calcProtobufSize();
            if (size == 0) {
                return &[_]u8{};
            }
            const buf = try allocator.alloc(u8, self.calcProtobufSize());
            var writer = gremlin.Writer.init(buf);
            self.encodeTo(&writer);
            return buf;
        }
        pub fn encodeTo(self: *const TestVersioningV2.Sub2V2, target: *gremlin.Writer) void {
            if (self.sub2_int != 0) {
                target.appendInt32(TestVersioningV2.Sub2V2Wire.SUB2_INT_WIRE, self.sub2_int);
            }
            if (self.sub2_string) |v| {
                if (v.len > 0) {
                    target.appendBytes(TestVersioningV2.Sub2V2Wire.SUB2_STRING_WIRE, v);
                }
            }
        }
    };
    pub const Sub2V2Reader = struct {
        buf: gremlin.Reader,
        _sub2_int: i32 = 0,
        _sub2_string: ?[]const u8 = null,
        pub fn init(src: []const u8) gremlin.Error!TestVersioningV2.Sub2V2Reader {
            const buf = gremlin.Reader.init(src);
            var res = TestVersioningV2.Sub2V2Reader{ .buf = buf };
            if (buf.buf.len == 0) {
                return res;
            }
            var offset: usize = 0;
            while (buf.hasNext(offset, 0)) {
                const tag = try buf.readTagAt(offset);
                offset += tag.size;
                switch (tag.number) {
                    TestVersioningV2.Sub2V2Wire.SUB2_INT_WIRE => {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._sub2_int = result.value;
                    },
                    TestVersioningV2.Sub2V2Wire.SUB2_STRING_WIRE => {
                        const result = try buf.readBytes(offset);
                        offset += result.size;
                        res._sub2_string = result.value;
                    },
                    else => {
                        offset = try buf.skipData(offset, tag.wire);
                    },
                }
            }
            return res;
        }
        pub fn sourceBytes(self: *const @This()) []const u8 {
            return self.buf.buf;
        }
        pub inline fn getSub2Int(self: *const TestVersioningV2.Sub2V2Reader) i32 {
            return self._sub2_int;
        }
        pub inline fn getSub2String(self: *const TestVersioningV2.Sub2V2Reader) []const u8 {
            return self._sub2_string orelse &[_]u8{};
        }
    };
    // fields
    root_int: i32 = 0,
    enumz: ?[]const TestVersioningV2.EnumzV2 = null,
    root_string: ?[]const u8 = null,
    rep_string: ?[]const ?[]const u8 = null,
    sub1: ?TestVersioningV2.Sub1V2 = null,
    sub1_rep: ?[]const ?TestVersioningV2.Sub1V2 = null,
    sub1_lazy: ?TestVersioningV2.Sub1V2 = null,
    root_int_v2: i32 = 0,
    sub2: ?TestVersioningV2.Sub2V2 = null,
    sub2_rep: ?[]const ?TestVersioningV2.Sub2V2 = null,
    sub2_lazy: ?TestVersioningV2.Sub2V2 = null,
    pub fn calcProtobufSize(self: *const TestVersioningV2) usize {
        var res: usize = 0;
        if (self.root_int != 0) {
            res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.ROOT_INT_WIRE) + gremlin.sizes.sizeI32(self.root_int);
        }
        if (self.enumz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.ENUMZ_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.ENUMZ_WIRE) + gremlin.sizes.sizeUsize(packed_size) + packed_size;
            }
        }
        if (self.root_string) |v| {
            if (v.len > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.ROOT_STRING_WIRE) + gremlin.sizes.sizeUsize(v.len) + v.len;
            }
        }
        if (self.rep_string) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.REP_STRING_WIRE);
                if (maybe_v) |v| {
                    res += gremlin.sizes.sizeUsize(v.len) + v.len;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sub1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB1_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sub1_rep) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB1_REP_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sub1_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB1_LAZY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.root_int_v2 != 0) {
            res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.ROOT_INT_V2_WIRE) + gremlin.sizes.sizeI32(self.root_int_v2);
        }
        if (self.sub2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB2_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.sub2_rep) |arr| {
            for (arr) |maybe_v| {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB2_REP_WIRE);
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    res += gremlin.sizes.sizeUsize(size) + size;
                } else {
                    res += gremlin.sizes.sizeUsize(0);
                }
            }
        }
        if (self.sub2_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(TestVersioningV2Wire.SUB2_LAZY_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        return res;
    }
    pub fn encode(self: *const TestVersioningV2, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const TestVersioningV2, target: *gremlin.Writer) void {
        if (self.root_int != 0) {
            target.appendInt32(TestVersioningV2Wire.ROOT_INT_WIRE, self.root_int);
        }
        if (self.enumz) |arr| {
            if (arr.len == 0) {} else if (arr.len == 1) {
                target.appendInt32(TestVersioningV2Wire.ENUMZ_WIRE, @intFromEnum(arr[0]));
            } else {
                var packed_size: usize = 0;
                for (arr) |v| {
                    packed_size += gremlin.sizes.sizeI32(@intFromEnum(v));
                }
                target.appendBytesTag(TestVersioningV2Wire.ENUMZ_WIRE, packed_size);
                for (arr) |v| {
                    target.appendInt32WithoutTag(@intFromEnum(v));
                }
            }
        }
        if (self.root_string) |v| {
            if (v.len > 0) {
                target.appendBytes(TestVersioningV2Wire.ROOT_STRING_WIRE, v);
            }
        }
        if (self.rep_string) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    target.appendBytes(TestVersioningV2Wire.REP_STRING_WIRE, v);
                } else {
                    target.appendBytesTag(TestVersioningV2Wire.REP_STRING_WIRE, 0);
                }
            }
        }
        if (self.sub1) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV2Wire.SUB1_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sub1_rep) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TestVersioningV2Wire.SUB1_REP_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TestVersioningV2Wire.SUB1_REP_WIRE, 0);
                }
            }
        }
        if (self.sub1_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV2Wire.SUB1_LAZY_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.root_int_v2 != 0) {
            target.appendInt32(TestVersioningV2Wire.ROOT_INT_V2_WIRE, self.root_int_v2);
        }
        if (self.sub2) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV2Wire.SUB2_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.sub2_rep) |arr| {
            for (arr) |maybe_v| {
                if (maybe_v) |v| {
                    const size = v.calcProtobufSize();
                    target.appendBytesTag(TestVersioningV2Wire.SUB2_REP_WIRE, size);
                    v.encodeTo(target);
                } else {
                    target.appendBytesTag(TestVersioningV2Wire.SUB2_REP_WIRE, 0);
                }
            }
        }
        if (self.sub2_lazy) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(TestVersioningV2Wire.SUB2_LAZY_WIRE, size);
                v.encodeTo(target);
            }
        }
    }
};
pub const TestVersioningV2Reader = struct {
    buf: gremlin.Reader,
    _root_int: i32 = 0,
    _enumz_offset: ?usize = null,
    _enumz_last_offset: ?usize = null,
    _enumz_packed: bool = false,
    _root_string: ?[]const u8 = null,
    _rep_string_offset: ?usize = null,
    _rep_string_last_offset: ?usize = null,
    _rep_string_cnt: usize = 0,
    _sub1_buf: ?[]const u8 = null,
    _sub1_rep_offset: ?usize = null,
    _sub1_rep_last_offset: ?usize = null,
    _sub1_rep_cnt: usize = 0,
    _sub1_lazy_buf: ?[]const u8 = null,
    _root_int_v2: i32 = 0,
    _sub2_buf: ?[]const u8 = null,
    _sub2_rep_offset: ?usize = null,
    _sub2_rep_last_offset: ?usize = null,
    _sub2_rep_cnt: usize = 0,
    _sub2_lazy_buf: ?[]const u8 = null,
    pub fn init(src: []const u8) gremlin.Error!TestVersioningV2Reader {
        const buf = gremlin.Reader.init(src);
        var res = TestVersioningV2Reader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                TestVersioningV2Wire.ROOT_INT_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._root_int = result.value;
                },
                TestVersioningV2Wire.ENUMZ_WIRE => {
                    if (res._enumz_offset == null) {
                        res._enumz_offset = offset;
                    }
                    if (tag.wire == gremlin.ProtoWireType.bytes) {
                        res._enumz_packed = true;
                        const length_result = try buf.readVarInt(offset);
                        res._enumz_offset = offset + length_result.size;
                        res._enumz_last_offset = offset + length_result.size + @as(usize, @intCast(length_result.value));
                        offset = res._enumz_last_offset.?;
                    } else {
                        const result = try buf.readInt32(offset);
                        offset += result.size;
                        res._enumz_last_offset = offset;
                    }
                },
                TestVersioningV2Wire.ROOT_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._root_string = result.value;
                },
                TestVersioningV2Wire.REP_STRING_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._rep_string_offset == null) {
                        res._rep_string_offset = offset - result.size;
                    }
                    res._rep_string_last_offset = offset;
                    res._rep_string_cnt += 1;
                },
                TestVersioningV2Wire.SUB1_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub1_buf = result.value;
                },
                TestVersioningV2Wire.SUB1_REP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sub1_rep_offset == null) {
                        res._sub1_rep_offset = offset - result.size;
                    }
                    res._sub1_rep_last_offset = offset;
                    res._sub1_rep_cnt += 1;
                },
                TestVersioningV2Wire.SUB1_LAZY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub1_lazy_buf = result.value;
                },
                TestVersioningV2Wire.ROOT_INT_V2_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._root_int_v2 = result.value;
                },
                TestVersioningV2Wire.SUB2_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub2_buf = result.value;
                },
                TestVersioningV2Wire.SUB2_REP_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    if (res._sub2_rep_offset == null) {
                        res._sub2_rep_offset = offset - result.size;
                    }
                    res._sub2_rep_last_offset = offset;
                    res._sub2_rep_cnt += 1;
                },
                TestVersioningV2Wire.SUB2_LAZY_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._sub2_lazy_buf = result.value;
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub inline fn getRootInt(self: *const TestVersioningV2Reader) i32 {
        return self._root_int;
    }
    pub fn enumzNext(self: *TestVersioningV2Reader) gremlin.Error!?TestVersioningV2.EnumzV2 {
        if (self._enumz_offset == null) return null;
        const current_offset = self._enumz_offset.?;
        if (current_offset >= self._enumz_last_offset.?) {
            self._enumz_offset = null;
            return null;
        }
        if (self._enumz_packed) {
            const value_result = try self.buf.readInt32(current_offset);
            self._enumz_offset = current_offset + value_result.size;
            if (self._enumz_offset.? >= self._enumz_last_offset.?) {
                self._enumz_offset = null;
            }
            return @enumFromInt(value_result.value);
        } else {
            const value_result = try self.buf.readInt32(current_offset);
            var next_offset = current_offset + value_result.size;
            const max_offset = self._enumz_last_offset.?;
            // Search for the next occurrence of this field
            while (next_offset < max_offset and self.buf.hasNext(next_offset, 0)) {
                const next_tag = try self.buf.readTagAt(next_offset);
                next_offset += next_tag.size;
                if (next_tag.number == TestVersioningV2Wire.ENUMZ_WIRE) {
                    self._enumz_offset = next_offset;
                    return @enumFromInt(value_result.value);
                } else {
                    next_offset = try self.buf.skipData(next_offset, next_tag.wire);
                }
            }
            self._enumz_offset = null;
            return @enumFromInt(value_result.value);
        }
    }
    pub inline fn getRootString(self: *const TestVersioningV2Reader) []const u8 {
        return self._root_string orelse &[_]u8{};
    }
    pub fn repStringCount(self: *const TestVersioningV2Reader) usize {
        return self._rep_string_cnt;
    }
    pub fn repStringNext(self: *TestVersioningV2Reader) ?[]const u8 {
        if (self._rep_string_offset == null) return null;
        const current_offset = self._rep_string_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        if (self._rep_string_last_offset != null and current_offset >= self._rep_string_last_offset.?) {
            self._rep_string_offset = null;
            return result.value;
        }
        if (self._rep_string_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._rep_string_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestVersioningV2Wire.REP_STRING_WIRE) {
                self._rep_string_offset = next_offset;
                return result.value;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._rep_string_offset = null;
        return result.value;
    }
    pub fn getSub1(self: *const TestVersioningV2Reader) gremlin.Error!TestVersioningV2.Sub1V2Reader {
        if (self._sub1_buf) |buf| {
            return try TestVersioningV2.Sub1V2Reader.init(buf);
        }
        return try TestVersioningV2.Sub1V2Reader.init(&[_]u8{});
    }
    pub fn sub1RepCount(self: *const TestVersioningV2Reader) usize {
        return self._sub1_rep_cnt;
    }
    pub fn sub1RepNext(self: *TestVersioningV2Reader) ?TestVersioningV2.Sub1V2Reader {
        if (self._sub1_rep_offset == null) return null;
        const current_offset = self._sub1_rep_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TestVersioningV2.Sub1V2Reader.init(result.value) catch return null;
        if (self._sub1_rep_last_offset != null and current_offset >= self._sub1_rep_last_offset.?) {
            self._sub1_rep_offset = null;
            return msg;
        }
        if (self._sub1_rep_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sub1_rep_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestVersioningV2Wire.SUB1_REP_WIRE) {
                self._sub1_rep_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sub1_rep_offset = null;
        return msg;
    }
    pub fn getSub1Lazy(self: *const TestVersioningV2Reader) gremlin.Error!TestVersioningV2.Sub1V2Reader {
        if (self._sub1_lazy_buf) |buf| {
            return try TestVersioningV2.Sub1V2Reader.init(buf);
        }
        return try TestVersioningV2.Sub1V2Reader.init(&[_]u8{});
    }
    pub inline fn getRootIntV2(self: *const TestVersioningV2Reader) i32 {
        return self._root_int_v2;
    }
    pub fn getSub2(self: *const TestVersioningV2Reader) gremlin.Error!TestVersioningV2.Sub2V2Reader {
        if (self._sub2_buf) |buf| {
            return try TestVersioningV2.Sub2V2Reader.init(buf);
        }
        return try TestVersioningV2.Sub2V2Reader.init(&[_]u8{});
    }
    pub fn sub2RepCount(self: *const TestVersioningV2Reader) usize {
        return self._sub2_rep_cnt;
    }
    pub fn sub2RepNext(self: *TestVersioningV2Reader) ?TestVersioningV2.Sub2V2Reader {
        if (self._sub2_rep_offset == null) return null;
        const current_offset = self._sub2_rep_offset.?;
        const result = self.buf.readBytes(current_offset) catch return null;
        const msg = TestVersioningV2.Sub2V2Reader.init(result.value) catch return null;
        if (self._sub2_rep_last_offset != null and current_offset >= self._sub2_rep_last_offset.?) {
            self._sub2_rep_offset = null;
            return msg;
        }
        if (self._sub2_rep_last_offset == null) unreachable;
        var next_offset = current_offset + result.size;
        const max_offset = self._sub2_rep_last_offset.?;
        while (next_offset <= max_offset and self.buf.hasNext(next_offset, 0)) {
            const tag = self.buf.readTagAt(next_offset) catch break;
            next_offset += tag.size;
            if (tag.number == TestVersioningV2Wire.SUB2_REP_WIRE) {
                self._sub2_rep_offset = next_offset;
                return msg;
            } else {
                next_offset = self.buf.skipData(next_offset, tag.wire) catch break;
            }
        }
        self._sub2_rep_offset = null;
        return msg;
    }
    pub fn getSub2Lazy(self: *const TestVersioningV2Reader) gremlin.Error!TestVersioningV2.Sub2V2Reader {
        if (self._sub2_lazy_buf) |buf| {
            return try TestVersioningV2.Sub2V2Reader.init(buf);
        }
        return try TestVersioningV2.Sub2V2Reader.init(&[_]u8{});
    }
};
const DifferentPackagesWire = struct {
    const SUBPACKAGE_MESSAGE_WIRE: gremlin.ProtoWireNumber = 1;
    const SUBPACKAGE_NESTED_MESSAGE_WIRE: gremlin.ProtoWireNumber = 2;
    const SUBPACKAGE_ENUM_WIRE: gremlin.ProtoWireNumber = 3;
    const SUBPACKAGE_NESTED_ENUM_WIRE: gremlin.ProtoWireNumber = 4;
    const OTHERPACKAGE_MESSAGE_WIRE: gremlin.ProtoWireNumber = 5;
    const OTHERPACKAGE_NESTED_MESSAGE_WIRE: gremlin.ProtoWireNumber = 6;
    const OTHERPACKAGE_ENUM_WIRE: gremlin.ProtoWireNumber = 7;
    const OTHERPACKAGE_NESTED_ENUM_WIRE: gremlin.ProtoWireNumber = 8;
};
pub const DifferentPackages = struct {
    // fields
    subpackage_message: ?test_messages.Message = null,
    subpackage_nested_message: ?test_messages.Message.NestedMessage = null,
    subpackage_enum: test_messages.Enum = @enumFromInt(0),
    subpackage_nested_enum: test_messages.Message.NestedEnum = @enumFromInt(0),
    otherpackage_message: ?test_messages.Message = null,
    otherpackage_nested_message: ?test_messages.Message.NestedMessage = null,
    otherpackage_enum: test_messages.Enum = @enumFromInt(0),
    otherpackage_nested_enum: test_messages.Message.NestedEnum = @enumFromInt(0),
    pub fn calcProtobufSize(self: *const DifferentPackages) usize {
        var res: usize = 0;
        if (self.subpackage_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.SUBPACKAGE_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.subpackage_nested_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.SUBPACKAGE_NESTED_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.subpackage_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.SUBPACKAGE_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.subpackage_enum));
        }
        if (@intFromEnum(self.subpackage_nested_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.SUBPACKAGE_NESTED_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.subpackage_nested_enum));
        }
        if (self.otherpackage_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.OTHERPACKAGE_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (self.otherpackage_nested_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.OTHERPACKAGE_NESTED_MESSAGE_WIRE) + gremlin.sizes.sizeUsize(size) + size;
            }
        }
        if (@intFromEnum(self.otherpackage_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.OTHERPACKAGE_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.otherpackage_enum));
        }
        if (@intFromEnum(self.otherpackage_nested_enum) != 0) {
            res += gremlin.sizes.sizeWireNumber(DifferentPackagesWire.OTHERPACKAGE_NESTED_ENUM_WIRE) + gremlin.sizes.sizeI32(@intFromEnum(self.otherpackage_nested_enum));
        }
        return res;
    }
    pub fn encode(self: *const DifferentPackages, allocator: std.mem.Allocator) gremlin.Error![]const u8 {
        const size = self.calcProtobufSize();
        if (size == 0) {
            return &[_]u8{};
        }
        const buf = try allocator.alloc(u8, self.calcProtobufSize());
        var writer = gremlin.Writer.init(buf);
        self.encodeTo(&writer);
        return buf;
    }
    pub fn encodeTo(self: *const DifferentPackages, target: *gremlin.Writer) void {
        if (self.subpackage_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DifferentPackagesWire.SUBPACKAGE_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.subpackage_nested_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DifferentPackagesWire.SUBPACKAGE_NESTED_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.subpackage_enum) != 0) {
            target.appendInt32(DifferentPackagesWire.SUBPACKAGE_ENUM_WIRE, @intFromEnum(self.subpackage_enum));
        }
        if (@intFromEnum(self.subpackage_nested_enum) != 0) {
            target.appendInt32(DifferentPackagesWire.SUBPACKAGE_NESTED_ENUM_WIRE, @intFromEnum(self.subpackage_nested_enum));
        }
        if (self.otherpackage_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DifferentPackagesWire.OTHERPACKAGE_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (self.otherpackage_nested_message) |v| {
            const size = v.calcProtobufSize();
            if (size > 0) {
                target.appendBytesTag(DifferentPackagesWire.OTHERPACKAGE_NESTED_MESSAGE_WIRE, size);
                v.encodeTo(target);
            }
        }
        if (@intFromEnum(self.otherpackage_enum) != 0) {
            target.appendInt32(DifferentPackagesWire.OTHERPACKAGE_ENUM_WIRE, @intFromEnum(self.otherpackage_enum));
        }
        if (@intFromEnum(self.otherpackage_nested_enum) != 0) {
            target.appendInt32(DifferentPackagesWire.OTHERPACKAGE_NESTED_ENUM_WIRE, @intFromEnum(self.otherpackage_nested_enum));
        }
    }
};
pub const DifferentPackagesReader = struct {
    buf: gremlin.Reader,
    _subpackage_message_buf: ?[]const u8 = null,
    _subpackage_nested_message_buf: ?[]const u8 = null,
    _subpackage_enum: test_messages.Enum = @enumFromInt(0),
    _subpackage_nested_enum: test_messages.Message.NestedEnum = @enumFromInt(0),
    _otherpackage_message_buf: ?[]const u8 = null,
    _otherpackage_nested_message_buf: ?[]const u8 = null,
    _otherpackage_enum: test_messages.Enum = @enumFromInt(0),
    _otherpackage_nested_enum: test_messages.Message.NestedEnum = @enumFromInt(0),
    pub fn init(src: []const u8) gremlin.Error!DifferentPackagesReader {
        const buf = gremlin.Reader.init(src);
        var res = DifferentPackagesReader{ .buf = buf };
        if (buf.buf.len == 0) {
            return res;
        }
        var offset: usize = 0;
        while (buf.hasNext(offset, 0)) {
            const tag = try buf.readTagAt(offset);
            offset += tag.size;
            switch (tag.number) {
                DifferentPackagesWire.SUBPACKAGE_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._subpackage_message_buf = result.value;
                },
                DifferentPackagesWire.SUBPACKAGE_NESTED_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._subpackage_nested_message_buf = result.value;
                },
                DifferentPackagesWire.SUBPACKAGE_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._subpackage_enum = @enumFromInt(result.value);
                },
                DifferentPackagesWire.SUBPACKAGE_NESTED_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._subpackage_nested_enum = @enumFromInt(result.value);
                },
                DifferentPackagesWire.OTHERPACKAGE_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._otherpackage_message_buf = result.value;
                },
                DifferentPackagesWire.OTHERPACKAGE_NESTED_MESSAGE_WIRE => {
                    const result = try buf.readBytes(offset);
                    offset += result.size;
                    res._otherpackage_nested_message_buf = result.value;
                },
                DifferentPackagesWire.OTHERPACKAGE_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._otherpackage_enum = @enumFromInt(result.value);
                },
                DifferentPackagesWire.OTHERPACKAGE_NESTED_ENUM_WIRE => {
                    const result = try buf.readInt32(offset);
                    offset += result.size;
                    res._otherpackage_nested_enum = @enumFromInt(result.value);
                },
                else => {
                    offset = try buf.skipData(offset, tag.wire);
                },
            }
        }
        return res;
    }
    pub fn sourceBytes(self: *const @This()) []const u8 {
        return self.buf.buf;
    }
    pub fn getSubpackageMessage(self: *const DifferentPackagesReader) gremlin.Error!test_messages.MessageReader {
        if (self._subpackage_message_buf) |buf| {
            return try test_messages.MessageReader.init(buf);
        }
        return try test_messages.MessageReader.init(&[_]u8{});
    }
    pub fn getSubpackageNestedMessage(self: *const DifferentPackagesReader) gremlin.Error!test_messages.Message.NestedMessageReader {
        if (self._subpackage_nested_message_buf) |buf| {
            return try test_messages.Message.NestedMessageReader.init(buf);
        }
        return try test_messages.Message.NestedMessageReader.init(&[_]u8{});
    }
    pub inline fn getSubpackageEnum(self: *const DifferentPackagesReader) test_messages.Enum {
        return self._subpackage_enum;
    }
    pub inline fn getSubpackageNestedEnum(self: *const DifferentPackagesReader) test_messages.Message.NestedEnum {
        return self._subpackage_nested_enum;
    }
    pub fn getOtherpackageMessage(self: *const DifferentPackagesReader) gremlin.Error!test_messages.MessageReader {
        if (self._otherpackage_message_buf) |buf| {
            return try test_messages.MessageReader.init(buf);
        }
        return try test_messages.MessageReader.init(&[_]u8{});
    }
    pub fn getOtherpackageNestedMessage(self: *const DifferentPackagesReader) gremlin.Error!test_messages.Message.NestedMessageReader {
        if (self._otherpackage_nested_message_buf) |buf| {
            return try test_messages.Message.NestedMessageReader.init(buf);
        }
        return try test_messages.Message.NestedMessageReader.init(&[_]u8{});
    }
    pub inline fn getOtherpackageEnum(self: *const DifferentPackagesReader) test_messages.Enum {
        return self._otherpackage_enum;
    }
    pub inline fn getOtherpackageNestedEnum(self: *const DifferentPackagesReader) test_messages.Message.NestedEnum {
        return self._otherpackage_nested_enum;
    }
};
